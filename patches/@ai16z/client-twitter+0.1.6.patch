diff -Naur node_modules/@ai16z/client-twitter.original/LICENSE node_modules/@ai16z/client-twitter/LICENSE
--- node_modules/@ai16z/client-twitter.original/LICENSE	1969-12-31 20:00:00.000000000 -0400
+++ node_modules/@ai16z/client-twitter/LICENSE	2025-01-12 20:44:04.219843825 -0400
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2024 Shaw Walters, aka Moon aka @lalalune
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
\ No newline at end of file
diff -Naur node_modules/@ai16z/client-twitter.original/dist/index.d.ts node_modules/@ai16z/client-twitter/dist/index.d.ts
--- node_modules/@ai16z/client-twitter.original/dist/index.d.ts	1969-12-31 20:00:00.000000000 -0400
+++ node_modules/@ai16z/client-twitter/dist/index.d.ts	2025-01-12 20:44:04.768893881 -0400
@@ -0,0 +1,5 @@
+import { Client } from '@ai16z/eliza';
+
+declare const TwitterClientInterface: Client;
+
+export { TwitterClientInterface, TwitterClientInterface as default };
diff -Naur node_modules/@ai16z/client-twitter.original/dist/index.js node_modules/@ai16z/client-twitter/dist/index.js
--- node_modules/@ai16z/client-twitter.original/dist/index.js	1969-12-31 20:00:00.000000000 -0400
+++ node_modules/@ai16z/client-twitter/dist/index.js	2025-01-15 22:36:14.116228393 -0400
@@ -0,0 +1,2320 @@
+// src/index.ts
+import { elizaLogger as elizaLogger5 } from "@ai16z/eliza";
+
+// src/base.ts
+import {
+  getEmbeddingZeroVector,
+  elizaLogger,
+  stringToUuid
+} from "@ai16z/eliza";
+import {
+  Scraper,
+  SearchMode
+} from "agent-twitter-client";
+import { EventEmitter } from "events";
+var RequestQueue = class {
+  queue = [];
+  processing = false;
+  async add(request) {
+    return new Promise((resolve, reject) => {
+      this.queue.push(async () => {
+        try {
+          const result = await request();
+          resolve(result);
+        } catch (error) {
+          reject(error);
+        }
+      });
+      this.processQueue();
+    });
+  }
+  async processQueue() {
+    if (this.processing || this.queue.length === 0) {
+      return;
+    }
+    this.processing = true;
+    while (this.queue.length > 0) {
+      const request = this.queue.shift();
+      try {
+        await request();
+      } catch (error) {
+        console.error("Error processing request:", error);
+        this.queue.unshift(request);
+        await this.exponentialBackoff(this.queue.length);
+      }
+      await this.randomDelay();
+    }
+    this.processing = false;
+  }
+  async exponentialBackoff(retryCount) {
+    const delay = Math.pow(2, retryCount) * 1e3;
+    await new Promise((resolve) => setTimeout(resolve, delay));
+  }
+  async randomDelay() {
+    const delay = Math.floor(Math.random() * 2e3) + 1500;
+    await new Promise((resolve) => setTimeout(resolve, delay));
+  }
+};
+var ClientBase = class _ClientBase extends EventEmitter {
+  static _twitterClients = {};
+  twitterClient;
+  runtime;
+  directions;
+  lastCheckedTweetId = null;
+  imageDescriptionService;
+  temperature = 0.5;
+  requestQueue = new RequestQueue();
+  profile;
+  async cacheTweet(tweet) {
+    if (!tweet) {
+      console.warn("Tweet is undefined, skipping cache");
+      return;
+    }
+    this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);
+  }
+  async getCachedTweet(tweetId) {
+    const cached = await this.runtime.cacheManager.get(
+      `twitter/tweets/${tweetId}`
+    );
+    return cached;
+  }
+  async getTweet(tweetId) {
+    const cachedTweet = await this.getCachedTweet(tweetId);
+    if (cachedTweet) {
+      return cachedTweet;
+    }
+    const tweet = await this.requestQueue.add(
+      () => this.twitterClient.getTweet(tweetId)
+    );
+    await this.cacheTweet(tweet);
+    return tweet;
+  }
+  callback = null;
+  onReady() {
+    throw new Error(
+      "Not implemented in base class, please call from subclass"
+    );
+  }
+  constructor(runtime) {
+    super();
+    this.runtime = runtime;
+    const username = this.runtime.getSetting("TWITTER_USERNAME");
+    if (_ClientBase._twitterClients[username]) {
+      this.twitterClient = _ClientBase._twitterClients[username];
+    } else {
+      this.twitterClient = new Scraper();
+      _ClientBase._twitterClients[username] = this.twitterClient;
+    }
+    this.directions = "- " + this.runtime.character.style.all.join("\n- ") + "- " + this.runtime.character.style.post.join();
+  }
+  async init() {
+    const username = this.runtime.getSetting("TWITTER_USERNAME");
+    const password = this.runtime.getSetting("TWITTER_PASSWORD");
+    const email = this.runtime.getSetting("TWITTER_EMAIL");
+    let retries = parseInt(
+      this.runtime.getSetting("TWITTER_RETRY_LIMIT") || "5",
+      10
+    );
+    const twitter2faSecret = this.runtime.getSetting("TWITTER_2FA_SECRET") || void 0;
+    const cookies = this.runtime.getSetting("TWITTER_COOKIES");
+    if (!username) {
+      throw new Error("Twitter username not configured");
+    }
+    if (cookies) {
+      elizaLogger.debug("Using cookies from settings");
+      const cookiesArray = JSON.parse(cookies);
+      await this.setCookiesFromArray(cookiesArray);
+    } else {
+      elizaLogger.debug("No cookies found in settings");
+      elizaLogger.debug("Checking for cached cookies");
+      const cachedCookies = await this.getCachedCookies(username);
+      if (cachedCookies) {
+        await this.setCookiesFromArray(cachedCookies);
+      }
+    }
+    elizaLogger.log("Waiting for Twitter login");
+    while (retries > 0) {
+      const cookies2 = await this.twitterClient.getCookies();
+      if (await this.twitterClient.isLoggedIn() && !!cookies2) {
+        elizaLogger.info("Already logged in.");
+        await this.cacheCookies(username, cookies2);
+        elizaLogger.info("Successfully logged in and cookies cached.");
+        break;
+      }
+      try {
+        await this.twitterClient.login(
+          username,
+          password,
+          email,
+          twitter2faSecret
+        );
+      } catch (error) {
+        elizaLogger.error(`Login attempt failed: ${error.message}`);
+      }
+      retries--;
+      elizaLogger.error(
+        `Failed to login to Twitter. Retrying... (${retries} attempts left)`
+      );
+      if (retries === 0) {
+        elizaLogger.error(
+          "Max retries reached. Exiting login process."
+        );
+        throw new Error("Twitter login failed after maximum retries.");
+      }
+      await new Promise((resolve) => setTimeout(resolve, 2e3));
+    }
+    this.profile = await this.fetchProfile(username);
+    if (this.profile) {
+      elizaLogger.log("Twitter user ID:", this.profile.id);
+      elizaLogger.log(
+        "Twitter loaded:",
+        JSON.stringify(this.profile, null, 10)
+      );
+      this.runtime.character.twitterProfile = {
+        id: this.profile.id,
+        username: this.profile.username,
+        screenName: this.profile.screenName,
+        bio: this.profile.bio,
+        nicknames: this.profile.nicknames
+      };
+    } else {
+      throw new Error("Failed to load profile");
+    }
+    await this.loadLatestCheckedTweetId();
+    await this.populateTimeline();
+  }
+  async fetchOwnPosts(count) {
+    elizaLogger.debug("fetching own posts");
+    const homeTimeline = await this.twitterClient.getUserTweets(
+      this.profile.id,
+      count
+    );
+    return homeTimeline.tweets;
+  }
+  async fetchHomeTimeline(count) {
+    elizaLogger.debug("fetching home timeline");
+    const homeTimeline = await this.twitterClient.fetchHomeTimeline(
+      count,
+      []
+    );
+    elizaLogger.debug(homeTimeline, { depth: Infinity });
+    const processedTimeline = homeTimeline.filter((t) => t.__typename !== "TweetWithVisibilityResults").map((tweet) => {
+      const obj = {
+        id: tweet.id,
+        name: tweet.name ?? tweet?.user_results?.result?.legacy.name,
+        username: tweet.username ?? tweet.core?.user_results?.result?.legacy.screen_name,
+        text: tweet.text ?? tweet.legacy?.full_text,
+        inReplyToStatusId: tweet.inReplyToStatusId ?? tweet.legacy?.in_reply_to_status_id_str ?? null,
+        timestamp: new Date(tweet.legacy?.created_at).getTime() / 1e3,
+        createdAt: tweet.createdAt ?? tweet.legacy?.created_at ?? tweet.core?.user_results?.result?.legacy.created_at,
+        userId: tweet.userId ?? tweet.legacy?.user_id_str,
+        conversationId: tweet.conversationId ?? tweet.legacy?.conversation_id_str,
+        permanentUrl: `https://x.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,
+        hashtags: tweet.hashtags ?? tweet.legacy?.entities.hashtags,
+        mentions: tweet.mentions ?? tweet.legacy?.entities.user_mentions,
+        photos: tweet.photos ?? tweet.legacy?.entities.media?.filter(
+          (media) => media.type === "photo"
+        ) ?? [],
+        thread: tweet.thread || [],
+        urls: tweet.urls ?? tweet.legacy?.entities.urls,
+        videos: tweet.videos ?? tweet.legacy?.entities.media?.filter(
+          (media) => media.type === "video"
+        ) ?? []
+      };
+      return obj;
+    });
+    return processedTimeline;
+  }
+  async fetchTimelineForActions(count) {
+    elizaLogger.debug("fetching timeline for actions");
+    const homeTimeline = await this.twitterClient.fetchHomeTimeline(
+      count,
+      []
+    );
+    return homeTimeline.map((tweet) => ({
+      id: tweet.rest_id,
+      name: tweet.core?.user_results?.result?.legacy?.name,
+      username: tweet.core?.user_results?.result?.legacy?.screen_name,
+      text: tweet.legacy?.full_text,
+      inReplyToStatusId: tweet.legacy?.in_reply_to_status_id_str,
+      timestamp: new Date(tweet.legacy?.created_at).getTime() / 1e3,
+      userId: tweet.legacy?.user_id_str,
+      conversationId: tweet.legacy?.conversation_id_str,
+      permanentUrl: `https://twitter.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,
+      hashtags: tweet.legacy?.entities?.hashtags || [],
+      mentions: tweet.legacy?.entities?.user_mentions || [],
+      photos: tweet.legacy?.entities?.media?.filter(
+        (media) => media.type === "photo"
+      ) || [],
+      thread: tweet.thread || [],
+      urls: tweet.legacy?.entities?.urls || [],
+      videos: tweet.legacy?.entities?.media?.filter(
+        (media) => media.type === "video"
+      ) || []
+    }));
+  }
+  async fetchSearchTweets(query, maxTweets, searchMode, cursor) {
+    try {
+      const timeoutPromise = new Promise(
+        (resolve) => setTimeout(() => resolve({ tweets: [] }), 1e4)
+      );
+      try {
+        const result = await this.requestQueue.add(
+          async () => await Promise.race([
+            this.twitterClient.fetchSearchTweets(
+              query,
+              maxTweets,
+              searchMode,
+              cursor
+            ),
+            timeoutPromise
+          ])
+        );
+        return result ?? { tweets: [] };
+      } catch (error) {
+        elizaLogger.error("Error fetching search tweets:", error);
+        return { tweets: [] };
+      }
+    } catch (error) {
+      elizaLogger.error("Error fetching search tweets:", error);
+      return { tweets: [] };
+    }
+  }
+  async populateTimeline() {
+    elizaLogger.debug("populating timeline...");
+    const cachedTimeline = await this.getCachedTimeline();
+    if (cachedTimeline) {
+      const existingMemories2 = await this.runtime.messageManager.getMemoriesByRoomIds({
+        roomIds: cachedTimeline.map(
+          (tweet) => stringToUuid(
+            tweet.conversationId + "-" + this.runtime.agentId
+          )
+        )
+      });
+      const existingMemoryIds2 = new Set(
+        existingMemories2.map((memory) => memory.id.toString())
+      );
+      const someCachedTweetsExist = cachedTimeline.some(
+        (tweet) => existingMemoryIds2.has(
+          stringToUuid(tweet.id + "-" + this.runtime.agentId)
+        )
+      );
+      if (someCachedTweetsExist) {
+        const tweetsToSave2 = cachedTimeline.filter(
+          (tweet) => !existingMemoryIds2.has(
+            stringToUuid(tweet.id + "-" + this.runtime.agentId)
+          )
+        );
+        console.log({
+          processingTweets: tweetsToSave2.map((tweet) => tweet.id).join(",")
+        });
+        for (const tweet of tweetsToSave2) {
+          elizaLogger.log("Saving Tweet", tweet.id);
+          const roomId = stringToUuid(
+            tweet.conversationId + "-" + this.runtime.agentId
+          );
+          const userId = tweet.userId === this.profile.id ? this.runtime.agentId : stringToUuid(tweet.userId);
+          if (tweet.userId === this.profile.id) {
+            await this.runtime.ensureConnection(
+              this.runtime.agentId,
+              roomId,
+              this.profile.username,
+              this.profile.screenName,
+              "twitter"
+            );
+          } else {
+            await this.runtime.ensureConnection(
+              userId,
+              roomId,
+              tweet.username,
+              tweet.name,
+              "twitter"
+            );
+          }
+          const content = {
+            text: tweet.text,
+            url: tweet.permanentUrl,
+            source: "twitter",
+            inReplyTo: tweet.inReplyToStatusId ? stringToUuid(
+              tweet.inReplyToStatusId + "-" + this.runtime.agentId
+            ) : void 0
+          };
+          elizaLogger.log("Creating memory for tweet", tweet.id);
+          const memory = await this.runtime.messageManager.getMemoryById(
+            stringToUuid(tweet.id + "-" + this.runtime.agentId)
+          );
+          if (memory) {
+            elizaLogger.log(
+              "Memory already exists, skipping timeline population"
+            );
+            break;
+          }
+          await this.runtime.messageManager.createMemory({
+            id: stringToUuid(tweet.id + "-" + this.runtime.agentId),
+            userId,
+            content,
+            agentId: this.runtime.agentId,
+            roomId,
+            embedding: getEmbeddingZeroVector(),
+            createdAt: tweet.timestamp * 1e3
+          });
+          await this.cacheTweet(tweet);
+        }
+        elizaLogger.log(
+          `Populated ${tweetsToSave2.length} missing tweets from the cache.`
+        );
+        return;
+      }
+    }
+    const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);
+    const username = this.runtime.getSetting("TWITTER_USERNAME");
+    const mentionsAndInteractions = await this.fetchSearchTweets(
+      `@${username}`,
+      20,
+      SearchMode.Latest
+    );
+    const allTweets = [...timeline, ...mentionsAndInteractions.tweets];
+    const tweetIdsToCheck = /* @__PURE__ */ new Set();
+    const roomIds = /* @__PURE__ */ new Set();
+    for (const tweet of allTweets) {
+      tweetIdsToCheck.add(tweet.id);
+      roomIds.add(
+        stringToUuid(tweet.conversationId + "-" + this.runtime.agentId)
+      );
+    }
+    const existingMemories = await this.runtime.messageManager.getMemoriesByRoomIds({
+      roomIds: Array.from(roomIds)
+    });
+    const existingMemoryIds = new Set(
+      existingMemories.map((memory) => memory.id)
+    );
+    const tweetsToSave = allTweets.filter(
+      (tweet) => !existingMemoryIds.has(
+        stringToUuid(tweet.id + "-" + this.runtime.agentId)
+      )
+    );
+    elizaLogger.debug({
+      processingTweets: tweetsToSave.map((tweet) => tweet.id).join(",")
+    });
+    await this.runtime.ensureUserExists(
+      this.runtime.agentId,
+      this.profile.username,
+      this.runtime.character.name,
+      "twitter"
+    );
+    for (const tweet of tweetsToSave) {
+      elizaLogger.log("Saving Tweet", tweet.id);
+      const roomId = stringToUuid(
+        tweet.conversationId + "-" + this.runtime.agentId
+      );
+      const userId = tweet.userId === this.profile.id ? this.runtime.agentId : stringToUuid(tweet.userId);
+      if (tweet.userId === this.profile.id) {
+        await this.runtime.ensureConnection(
+          this.runtime.agentId,
+          roomId,
+          this.profile.username,
+          this.profile.screenName,
+          "twitter"
+        );
+      } else {
+        await this.runtime.ensureConnection(
+          userId,
+          roomId,
+          tweet.username,
+          tweet.name,
+          "twitter"
+        );
+      }
+      const content = {
+        text: tweet.text,
+        url: tweet.permanentUrl,
+        source: "twitter",
+        inReplyTo: tweet.inReplyToStatusId ? stringToUuid(tweet.inReplyToStatusId) : void 0
+      };
+      await this.runtime.messageManager.createMemory({
+        id: stringToUuid(tweet.id + "-" + this.runtime.agentId),
+        userId,
+        content,
+        agentId: this.runtime.agentId,
+        roomId,
+        embedding: getEmbeddingZeroVector(),
+        createdAt: tweet.timestamp * 1e3
+      });
+      await this.cacheTweet(tweet);
+    }
+    await this.cacheTimeline(timeline);
+    await this.cacheMentions(mentionsAndInteractions.tweets);
+  }
+  async setCookiesFromArray(cookiesArray) {
+    const cookieStrings = cookiesArray.map(
+      (cookie) => `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${cookie.secure ? "Secure" : ""}; ${cookie.httpOnly ? "HttpOnly" : ""}; SameSite=${cookie.sameSite || "Lax"}`
+    );
+    await this.twitterClient.setCookies(cookieStrings);
+  }
+  async saveRequestMessage(message, state) {
+    if (message.content.text) {
+      const recentMessage = await this.runtime.messageManager.getMemories(
+        {
+          roomId: message.roomId,
+          count: 1,
+          unique: false
+        }
+      );
+      if (recentMessage.length > 0 && recentMessage[0].content === message.content) {
+        elizaLogger.debug("Message already saved", recentMessage[0].id);
+      } else {
+        await this.runtime.messageManager.createMemory({
+          ...message,
+          embedding: getEmbeddingZeroVector()
+        });
+      }
+      await this.runtime.evaluate(message, {
+        ...state,
+        twitterClient: this.twitterClient
+      });
+    }
+  }
+  async loadLatestCheckedTweetId() {
+    const latestCheckedTweetId = await this.runtime.cacheManager.get(
+      `twitter/${this.profile.username}/latest_checked_tweet_id`
+    );
+    if (latestCheckedTweetId) {
+      this.lastCheckedTweetId = BigInt(latestCheckedTweetId);
+    }
+  }
+  async cacheLatestCheckedTweetId() {
+    if (this.lastCheckedTweetId) {
+      await this.runtime.cacheManager.set(
+        `twitter/${this.profile.username}/latest_checked_tweet_id`,
+        this.lastCheckedTweetId.toString()
+      );
+    }
+  }
+  async getCachedTimeline() {
+    return await this.runtime.cacheManager.get(
+      `twitter/${this.profile.username}/timeline`
+    );
+  }
+  async cacheTimeline(timeline) {
+    await this.runtime.cacheManager.set(
+      `twitter/${this.profile.username}/timeline`,
+      timeline,
+      { expires: Date.now() + 10 * 1e3 }
+    );
+  }
+  async cacheMentions(mentions) {
+    await this.runtime.cacheManager.set(
+      `twitter/${this.profile.username}/mentions`,
+      mentions,
+      { expires: Date.now() + 10 * 1e3 }
+    );
+  }
+  async getCachedCookies(username) {
+    return await this.runtime.cacheManager.get(
+      `twitter/${username}/cookies`
+    );
+  }
+  async cacheCookies(username, cookies) {
+    await this.runtime.cacheManager.set(
+      `twitter/${username}/cookies`,
+      cookies
+    );
+  }
+  async getCachedProfile(username) {
+    return await this.runtime.cacheManager.get(
+      `twitter/${username}/profile`
+    );
+  }
+  async cacheProfile(profile) {
+    await this.runtime.cacheManager.set(
+      `twitter/${profile.username}/profile`,
+      profile
+    );
+  }
+  async fetchProfile(username) {
+    const cached = await this.getCachedProfile(username);
+    if (cached) return cached;
+    try {
+      const profile = await this.requestQueue.add(async () => {
+        const profile2 = await this.twitterClient.getProfile(username);
+        return {
+          id: profile2.userId,
+          username,
+          screenName: profile2.name || this.runtime.character.name,
+          bio: profile2.biography || typeof this.runtime.character.bio === "string" ? this.runtime.character.bio : this.runtime.character.bio.length > 0 ? this.runtime.character.bio[0] : "",
+          nicknames: this.runtime.character.twitterProfile?.nicknames || []
+        };
+      });
+      this.cacheProfile(profile);
+      return profile;
+    } catch (error) {
+      console.error("Error fetching Twitter profile:", error);
+      return void 0;
+    }
+  }
+};
+
+// src/environment.ts
+import { z } from "zod";
+var DEFAULT_MAX_TWEET_LENGTH = 280;
+var twitterEnvSchema = z.object({
+  TWITTER_DRY_RUN: z.string().transform((val) => val.toLowerCase() === "true"),
+  TWITTER_USERNAME: z.string().min(1, "Twitter username is required"),
+  TWITTER_PASSWORD: z.string().min(1, "Twitter password is required"),
+  TWITTER_EMAIL: z.string().email("Valid Twitter email is required"),
+  TWITTER_COOKIES: z.string().optional(),
+  MAX_TWEET_LENGTH: z.string().pipe(z.coerce.number().min(0).int()).default(DEFAULT_MAX_TWEET_LENGTH.toString())
+});
+async function validateTwitterConfig(runtime) {
+  try {
+    const twitterConfig = {
+      TWITTER_DRY_RUN: runtime.getSetting("TWITTER_DRY_RUN") || process.env.TWITTER_DRY_RUN || "false",
+      TWITTER_USERNAME: runtime.getSetting("TWITTER_USERNAME") || process.env.TWITTER_USERNAME,
+      TWITTER_PASSWORD: runtime.getSetting("TWITTER_PASSWORD") || process.env.TWITTER_PASSWORD,
+      TWITTER_EMAIL: runtime.getSetting("TWITTER_EMAIL") || process.env.TWITTER_EMAIL,
+      TWITTER_COOKIES: runtime.getSetting("TWITTER_COOKIES") || process.env.TWITTER_COOKIES,
+      MAX_TWEET_LENGTH: runtime.getSetting("MAX_TWEET_LENGTH") || process.env.MAX_TWEET_LENGTH || DEFAULT_MAX_TWEET_LENGTH.toString()
+    };
+    return twitterEnvSchema.parse(twitterConfig);
+  } catch (error) {
+    if (error instanceof z.ZodError) {
+      const errorMessages = error.errors.map((err) => `${err.path.join(".")}: ${err.message}`).join("\n");
+      throw new Error(
+        `Twitter configuration validation failed:
+${errorMessages}`
+      );
+    }
+    throw error;
+  }
+}
+
+// src/interactions.ts
+import { SearchMode as SearchMode2 } from "agent-twitter-client";
+import {
+  composeContext,
+  generateMessageResponse,
+  generateShouldRespond,
+  messageCompletionFooter,
+  shouldRespondFooter,
+  ModelClass,
+  stringToUuid as stringToUuid3,
+  elizaLogger as elizaLogger3,
+  getEmbeddingZeroVector as getEmbeddingZeroVector3
+} from "@ai16z/eliza";
+
+// src/utils.ts
+import { getEmbeddingZeroVector as getEmbeddingZeroVector2 } from "@ai16z/eliza";
+import { stringToUuid as stringToUuid2 } from "@ai16z/eliza";
+import { elizaLogger as elizaLogger2 } from "@ai16z/eliza";
+import fs from "fs";
+import path from "path";
+var wait = (minTime = 1e3, maxTime = 3e3) => {
+  const waitTime = Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;
+  return new Promise((resolve) => setTimeout(resolve, waitTime));
+};
+async function buildConversationThread(tweet, client, maxReplies = 10) {
+  const thread = [];
+  const visited = /* @__PURE__ */ new Set();
+  async function processThread(currentTweet, depth = 0) {
+    elizaLogger2.debug("Processing tweet:", {
+      id: currentTweet.id,
+      inReplyToStatusId: currentTweet.inReplyToStatusId,
+      depth
+    });
+    if (!currentTweet) {
+      elizaLogger2.debug("No current tweet found for thread building");
+      return;
+    }
+    if (depth >= maxReplies) {
+      elizaLogger2.debug("Reached maximum reply depth", depth);
+      return;
+    }
+    const memory = await client.runtime.messageManager.getMemoryById(
+      stringToUuid2(currentTweet.id + "-" + client.runtime.agentId)
+    );
+    if (!memory) {
+      const roomId = stringToUuid2(
+        currentTweet.conversationId + "-" + client.runtime.agentId
+      );
+      const userId = stringToUuid2(currentTweet.userId);
+      await client.runtime.ensureConnection(
+        userId,
+        roomId,
+        currentTweet.username,
+        currentTweet.name,
+        "twitter"
+      );
+      await client.runtime.messageManager.createMemory({
+        id: stringToUuid2(
+          currentTweet.id + "-" + client.runtime.agentId
+        ),
+        agentId: client.runtime.agentId,
+        content: {
+          text: currentTweet.text,
+          source: "twitter",
+          url: currentTweet.permanentUrl,
+          inReplyTo: currentTweet.inReplyToStatusId ? stringToUuid2(
+            currentTweet.inReplyToStatusId + "-" + client.runtime.agentId
+          ) : void 0
+        },
+        createdAt: currentTweet.timestamp * 1e3,
+        roomId,
+        userId: currentTweet.userId === client.profile.id ? client.runtime.agentId : stringToUuid2(currentTweet.userId),
+        embedding: getEmbeddingZeroVector2()
+      });
+    }
+    if (visited.has(currentTweet.id)) {
+      elizaLogger2.debug("Already visited tweet:", currentTweet.id);
+      return;
+    }
+    visited.add(currentTweet.id);
+    thread.unshift(currentTweet);
+    elizaLogger2.debug("Current thread state:", {
+      length: thread.length,
+      currentDepth: depth,
+      tweetId: currentTweet.id
+    });
+    if (currentTweet.inReplyToStatusId) {
+      elizaLogger2.debug(
+        "Fetching parent tweet:",
+        currentTweet.inReplyToStatusId
+      );
+      try {
+        const parentTweet = await client.twitterClient.getTweet(
+          currentTweet.inReplyToStatusId
+        );
+        if (parentTweet) {
+          elizaLogger2.debug("Found parent tweet:", {
+            id: parentTweet.id,
+            text: parentTweet.text?.slice(0, 50)
+          });
+          await processThread(parentTweet, depth + 1);
+        } else {
+          elizaLogger2.debug(
+            "No parent tweet found for:",
+            currentTweet.inReplyToStatusId
+          );
+        }
+      } catch (error) {
+        elizaLogger2.error("Error fetching parent tweet:", {
+          tweetId: currentTweet.inReplyToStatusId,
+          error
+        });
+      }
+    } else {
+      elizaLogger2.debug(
+        "Reached end of reply chain at:",
+        currentTweet.id
+      );
+    }
+  }
+  await processThread(tweet, 0);
+  elizaLogger2.debug("Final thread built:", {
+    totalTweets: thread.length,
+    tweetIds: thread.map((t) => ({
+      id: t.id,
+      text: t.text?.slice(0, 50)
+    }))
+  });
+  return thread;
+}
+async function sendTweet(client, content, roomId, twitterUsername, inReplyTo) {
+  const tweetChunks = splitTweetContent(
+    content.text,
+    Number(client.runtime.getSetting("MAX_TWEET_LENGTH")) || DEFAULT_MAX_TWEET_LENGTH
+  );
+  const sentTweets = [];
+  let previousTweetId = inReplyTo;
+  for (const chunk of tweetChunks) {
+    let mediaData;
+    if (content.attachments && content.attachments.length > 0) {
+      mediaData = await Promise.all(
+        content.attachments.map(async (attachment) => {
+          if (/^(http|https):\/\//.test(attachment.url)) {
+            const response = await fetch(attachment.url);
+            if (!response.ok) {
+              throw new Error(
+                `Failed to fetch file: ${attachment.url}`
+              );
+            }
+            const mediaBuffer = Buffer.from(
+              await response.arrayBuffer()
+            );
+            const mediaType = attachment.contentType;
+            return { data: mediaBuffer, mediaType };
+          } else if (fs.existsSync(attachment.url)) {
+            const mediaBuffer = await fs.promises.readFile(
+              path.resolve(attachment.url)
+            );
+            const mediaType = attachment.contentType;
+            return { data: mediaBuffer, mediaType };
+          } else {
+            throw new Error(
+              `File not found: ${attachment.url}. Make sure the path is correct.`
+            );
+          }
+        })
+      );
+    }
+    const result = await client.requestQueue.add(
+      async () => await client.twitterClient.sendTweet(
+        chunk.trim(),
+        previousTweetId,
+        mediaData
+      )
+    );
+    const body = await result.json();
+    if (body?.data?.create_tweet?.tweet_results?.result) {
+      const tweetResult = body.data.create_tweet.tweet_results.result;
+      const finalTweet = {
+        id: tweetResult.rest_id,
+        text: tweetResult.legacy.full_text,
+        conversationId: tweetResult.legacy.conversation_id_str,
+        timestamp: new Date(tweetResult.legacy.created_at).getTime() / 1e3,
+        userId: tweetResult.legacy.user_id_str,
+        inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,
+        permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,
+        hashtags: [],
+        mentions: [],
+        photos: [],
+        thread: [],
+        urls: [],
+        videos: []
+      };
+      sentTweets.push(finalTweet);
+      previousTweetId = finalTweet.id;
+    } else {
+      console.error("Error sending chunk", chunk, "repsonse:", body);
+    }
+    await wait(1e3, 2e3);
+  }
+  const memories = sentTweets.map((tweet) => ({
+    id: stringToUuid2(tweet.id + "-" + client.runtime.agentId),
+    agentId: client.runtime.agentId,
+    userId: client.runtime.agentId,
+    content: {
+      text: tweet.text,
+      source: "twitter",
+      url: tweet.permanentUrl,
+      inReplyTo: tweet.inReplyToStatusId ? stringToUuid2(
+        tweet.inReplyToStatusId + "-" + client.runtime.agentId
+      ) : void 0
+    },
+    roomId,
+    embedding: getEmbeddingZeroVector2(),
+    createdAt: tweet.timestamp * 1e3
+  }));
+  return memories;
+}
+function splitTweetContent(content, maxLength) {
+  const paragraphs = content.split("\n\n").map((p) => p.trim());
+  const tweets = [];
+  let currentTweet = "";
+  for (const paragraph of paragraphs) {
+    if (!paragraph) continue;
+    if ((currentTweet + "\n\n" + paragraph).trim().length <= maxLength) {
+      if (currentTweet) {
+        currentTweet += "\n\n" + paragraph;
+      } else {
+        currentTweet = paragraph;
+      }
+    } else {
+      if (currentTweet) {
+        tweets.push(currentTweet.trim());
+      }
+      if (paragraph.length <= maxLength) {
+        currentTweet = paragraph;
+      } else {
+        const chunks = splitParagraph(paragraph, maxLength);
+        tweets.push(...chunks.slice(0, -1));
+        currentTweet = chunks[chunks.length - 1];
+      }
+    }
+  }
+  if (currentTweet) {
+    tweets.push(currentTweet.trim());
+  }
+  return tweets;
+}
+function splitParagraph(paragraph, maxLength) {
+  const sentences = paragraph.match(/[^\.!\?]+[\.!\?]+|[^\.!\?]+$/g) || [
+    paragraph
+  ];
+  const chunks = [];
+  let currentChunk = "";
+  for (const sentence of sentences) {
+    if ((currentChunk + " " + sentence).trim().length <= maxLength) {
+      if (currentChunk) {
+        currentChunk += " " + sentence;
+      } else {
+        currentChunk = sentence;
+      }
+    } else {
+      if (currentChunk) {
+        chunks.push(currentChunk.trim());
+      }
+      if (sentence.length <= maxLength) {
+        currentChunk = sentence;
+      } else {
+        const words = sentence.split(" ");
+        currentChunk = "";
+        for (const word of words) {
+          if ((currentChunk + " " + word).trim().length <= maxLength) {
+            if (currentChunk) {
+              currentChunk += " " + word;
+            } else {
+              currentChunk = word;
+            }
+          } else {
+            if (currentChunk) {
+              chunks.push(currentChunk.trim());
+            }
+            currentChunk = word;
+          }
+        }
+      }
+    }
+  }
+  if (currentChunk) {
+    chunks.push(currentChunk.trim());
+  }
+  return chunks;
+}
+
+// src/interactions.ts
+var twitterMessageHandlerTemplate = `
+# Areas of Expertise
+{{knowledge}}
+
+# About {{agentName}} (@{{twitterUserName}}):
+{{bio}}
+{{lore}}
+{{topics}}
+
+{{providers}}
+
+{{characterPostExamples}}
+
+{{postDirections}}
+
+Recent interactions between {{agentName}} and other users:
+{{recentPostInteractions}}
+
+{{recentPosts}}
+
+# Task: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:
+Current Post:
+{{currentPost}}
+
+Thread of Tweets You Are Replying To:
+{{formattedConversation}}
+
+{{actions}}
+# Task: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:
+{{actionNames}}
+Here is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)
+{{currentPost}}
+` + messageCompletionFooter;
+var twitterShouldRespondTemplate = (targetUsersStr) => `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with "true" or "false".
+
+Response options are RESPOND, IGNORE and STOP.
+
+PRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.
+
+For other users:
+- {{agentName}} should RESPOND to messages directed at them
+- {{agentName}} should RESPOND to conversations relevant to their background
+- {{agentName}} should IGNORE irrelevant messages
+- {{agentName}} should IGNORE very short messages unless directly addressed
+- {{agentName}} should STOP if asked to stop
+- {{agentName}} should STOP if conversation is concluded
+- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.
+
+{{recentPosts}}
+
+IMPORTANT: For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.
+
+{{recentPosts}}
+
+IMPORTANT: {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.
+
+{{currentPost}}
+
+Thread of Tweets You Are Replying To:
+
+{{formattedConversation}}
+
+# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.
+` + shouldRespondFooter;
+var TwitterInteractionClient = class {
+  client;
+  runtime;
+  constructor(client, runtime) {
+    this.client = client;
+    this.runtime = runtime;
+  }
+  async start() {
+    const handleTwitterInteractionsLoop = () => {
+      this.handleTwitterInteractions();
+      setTimeout(
+        handleTwitterInteractionsLoop,
+        Number(
+          this.runtime.getSetting("TWITTER_POLL_INTERVAL") || 120
+        ) * 1e3
+        // Default to 2 minutes
+      );
+    };
+    handleTwitterInteractionsLoop();
+  }
+  async handleTwitterInteractions() {
+    elizaLogger3.log("Checking Twitter interactions");
+    const targetUsersStr = this.runtime.getSetting("TWITTER_TARGET_USERS");
+    const twitterUsername = this.client.profile.username;
+    try {
+      const mentionCandidates = (await this.client.fetchSearchTweets(
+        `@${twitterUsername}`,
+        20,
+        SearchMode2.Latest
+      )).tweets;
+      elizaLogger3.log(
+        "Completed checking mentioned tweets:",
+        mentionCandidates.length
+      );
+      let uniqueTweetCandidates = [...mentionCandidates];
+      if (targetUsersStr && targetUsersStr.trim()) {
+        const TARGET_USERS = targetUsersStr.split(",").map((u) => u.trim()).filter((u) => u.length > 0);
+        elizaLogger3.log("Processing target users:", TARGET_USERS);
+        if (TARGET_USERS.length > 0) {
+          const tweetsByUser = /* @__PURE__ */ new Map();
+          for (const username of TARGET_USERS) {
+            try {
+              const userTweets = (await this.client.twitterClient.fetchSearchTweets(
+                `from:${username}`,
+                3,
+                SearchMode2.Latest
+              )).tweets;
+              
+              const validTweets = userTweets.filter((tweet) => {
+                const isUnprocessed = !this.client.lastCheckedTweetId || parseInt(tweet.id) > this.client.lastCheckedTweetId;
+                const isRecent = Date.now() - tweet.timestamp * 1e3 < 2 * 60 * 60 * 1e3;
+                elizaLogger3.log(`Tweet ${tweet.id} checks:`, {
+                  isUnprocessed,
+                  isRecent,
+                  isReply: tweet.isReply,
+                  isRetweet: tweet.isRetweet
+                });
+                return isUnprocessed && !tweet.isReply && !tweet.isRetweet && isRecent;
+              });
+              console.log("validTweets", JSON.stringify(validTweets, null, 2));
+              if (validTweets.length > 0) {
+                tweetsByUser.set(username, validTweets);
+                elizaLogger3.log(
+                  `Found ${validTweets.length} valid tweets from ${username}`
+                );
+              }
+            } catch (error) {
+              elizaLogger3.error(
+                `Error fetching tweets for ${username}:`,
+                error
+              );
+              continue;
+            }
+          }
+          const selectedTweets = [];
+          for (const [username, tweets] of tweetsByUser) {
+            if (tweets.length > 0) {
+              const randomTweet = tweets[Math.floor(Math.random() * tweets.length)];
+              selectedTweets.push(randomTweet);
+              elizaLogger3.log(
+                `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`
+              );
+            }
+          }
+          uniqueTweetCandidates = [
+            ...mentionCandidates,
+            ...selectedTweets
+          ];
+        }
+      } else {
+        elizaLogger3.log(
+          "No target users configured, processing only mentions"
+        );
+      }
+      uniqueTweetCandidates.sort((a, b) => a.id.localeCompare(b.id)).filter((tweet) => tweet.userId !== this.client.profile.id);
+      for (const tweet of uniqueTweetCandidates) {
+        if (!this.client.lastCheckedTweetId || BigInt(tweet.id) > this.client.lastCheckedTweetId) {
+          const tweetId = stringToUuid3(
+            tweet.id + "-" + this.runtime.agentId
+          );
+          const existingResponse = await this.runtime.messageManager.getMemoryById(
+            tweetId
+          );
+          if (existingResponse) {
+            elizaLogger3.log(
+              `Already responded to tweet ${tweet.id}, skipping`
+            );
+            continue;
+          }
+          elizaLogger3.log("New Tweet found", tweet.permanentUrl);
+          const roomId = stringToUuid3(
+            tweet.conversationId + "-" + this.runtime.agentId
+          );
+          const userIdUUID = tweet.userId === this.client.profile.id ? this.runtime.agentId : stringToUuid3(tweet.userId);
+          await this.runtime.ensureConnection(
+            userIdUUID,
+            roomId,
+            tweet.username,
+            tweet.name,
+            "twitter"
+          );
+          const thread = await buildConversationThread(
+            tweet,
+            this.client
+          );
+          console.log("tweet", JSON.stringify(tweet, null, 2));
+          const message = {
+            content: { 
+              text: tweet.text , 
+              image: tweet.photos[0]?.url,
+              username: tweet.username,
+              name: tweet.name,
+              conversationId: tweet.conversationId,
+              userId: tweet.userId,
+              permanentUrl: tweet.permanentUrl,
+              inReplyToStatusId: tweet.inReplyToStatusId
+            },
+            agentId: this.runtime.agentId,
+            userId: userIdUUID,
+            roomId
+          };
+          await this.handleTweet({
+            tweet,
+            message,
+            thread
+          });
+          this.client.lastCheckedTweetId = BigInt(tweet.id);
+        }
+      }
+      await this.client.cacheLatestCheckedTweetId();
+      elizaLogger3.log("Finished checking Twitter interactions");
+    } catch (error) {
+      elizaLogger3.error("Error handling Twitter interactions:", error);
+    }
+  }
+  async handleTweet({
+    tweet,
+    message,
+    thread
+  }) {
+    if (tweet.userId === this.client.profile.id) {
+      return;
+    }
+    if (!message.content.text) {
+      elizaLogger3.log("Skipping Tweet with no text", tweet.id);
+      return { text: "", action: "IGNORE" };
+    }
+    elizaLogger3.log("Processing Tweet: ", tweet.id);
+    const formatTweet = (tweet2) => {
+      return `  ID: ${tweet2.id}
+  From: ${tweet2.name} (@${tweet2.username})
+  Text: ${tweet2.text}`;
+    };
+    const currentPost = formatTweet(tweet);
+    elizaLogger3.debug("Thread: ", thread);
+    const formattedConversation = thread.map(
+      (tweet2) => `@${tweet2.username} (${new Date(
+        tweet2.timestamp * 1e3
+      ).toLocaleString("en-US", {
+        hour: "2-digit",
+        minute: "2-digit",
+        month: "short",
+        day: "numeric"
+      })}):
+        ${tweet2.text}`
+    ).join("\n\n");
+    elizaLogger3.debug("formattedConversation: ", formattedConversation);
+    let state = await this.runtime.composeState(message, {
+      twitterClient: this.client.twitterClient,
+      twitterUserName: this.runtime.getSetting("TWITTER_USERNAME"),
+      currentPost,
+      formattedConversation
+    });
+    const tweetId = stringToUuid3(tweet.id + "-" + this.runtime.agentId);
+    const tweetExists = await this.runtime.messageManager.getMemoryById(tweetId);
+    if (!tweetExists) {
+      elizaLogger3.log("tweet does not exist, saving");
+      const userIdUUID = stringToUuid3(tweet.userId);
+      const roomId = stringToUuid3(tweet.conversationId);
+      const message2 = {
+        id: tweetId,
+        agentId: this.runtime.agentId,
+        content: {
+          text: tweet.text,
+          url: tweet.permanentUrl,
+          inReplyTo: tweet.inReplyToStatusId ? stringToUuid3(
+            tweet.inReplyToStatusId + "-" + this.runtime.agentId
+          ) : void 0
+        },
+        userId: userIdUUID,
+        roomId,
+        createdAt: tweet.timestamp * 1e3
+      };
+      this.client.saveRequestMessage(message2, state);
+    }
+    const targetUsersStr = this.runtime.getSetting("TWITTER_TARGET_USERS");
+    const validTargetUsersStr = targetUsersStr && targetUsersStr.trim() ? targetUsersStr.split(",").map((u) => u.trim()).filter((u) => u.length > 0).join(",") : "";
+    const shouldRespondContext = composeContext({
+      state,
+      template: this.runtime.character.templates?.twitterShouldRespondTemplate || this.runtime.character?.templates?.shouldRespondTemplate || twitterShouldRespondTemplate(validTargetUsersStr)
+    });
+    const shouldRespond = await generateShouldRespond({
+      runtime: this.runtime,
+      context: shouldRespondContext,
+      modelClass: ModelClass.MEDIUM
+    });
+    if (shouldRespond !== "RESPOND") {
+      elizaLogger3.log("Not responding to message");
+      return { text: "Response Decision:", action: shouldRespond };
+    }
+    const context = composeContext({
+      state,
+      template: this.runtime.character.templates?.twitterMessageHandlerTemplate || this.runtime.character?.templates?.messageHandlerTemplate || twitterMessageHandlerTemplate
+    });
+    elizaLogger3.debug("Interactions prompt:\n" + context);
+    const response = await generateMessageResponse({
+      runtime: this.runtime,
+      context,
+      modelClass: ModelClass.LARGE
+    });
+    const removeQuotes = (str) => str.replace(/^['"](.*)['"]$/, "$1");
+    const stringId = stringToUuid3(tweet.id + "-" + this.runtime.agentId);
+    response.inReplyTo = stringId;
+    response.text = removeQuotes(response.text);
+    if (response.text) {
+      try {
+        const callback = async (response2) => {
+          const memories = await sendTweet(
+            this.client,
+            response2,
+            message.roomId,
+            this.runtime.getSetting("TWITTER_USERNAME"),
+            tweet.id
+          );
+          return memories;
+        };
+        const responseMessages = await callback(response);
+        state = await this.runtime.updateRecentMessageState(
+          state
+        );
+        for (const responseMessage of responseMessages) {
+          if (responseMessage === responseMessages[responseMessages.length - 1]) {
+            responseMessage.content.action = response.action;
+          } else {
+            responseMessage.content.action = "CONTINUE";
+          }
+          await this.runtime.messageManager.createMemory(
+            responseMessage
+          );
+        }
+        await this.runtime.processActions(
+          message,
+          responseMessages,
+          state,
+          callback
+        );
+        const responseInfo = `Context:
+
+${context}
+
+Selected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}
+Agent's Output:
+${response.text}`;
+        await this.runtime.cacheManager.set(
+          `twitter/tweet_generation_${tweet.id}.txt`,
+          responseInfo
+        );
+        await wait();
+      } catch (error) {
+        elizaLogger3.error(`Error sending response tweet: ${error}`);
+      }
+    }
+  }
+  async buildConversationThread(tweet, maxReplies = 10) {
+    const thread = [];
+    const visited = /* @__PURE__ */ new Set();
+    async function processThread(currentTweet, depth = 0) {
+      elizaLogger3.log("Processing tweet:", {
+        id: currentTweet.id,
+        inReplyToStatusId: currentTweet.inReplyToStatusId,
+        depth
+      });
+      if (!currentTweet) {
+        elizaLogger3.log("No current tweet found for thread building");
+        return;
+      }
+      if (depth >= maxReplies) {
+        elizaLogger3.log("Reached maximum reply depth", depth);
+        return;
+      }
+      const memory = await this.runtime.messageManager.getMemoryById(
+        stringToUuid3(currentTweet.id + "-" + this.runtime.agentId)
+      );
+      if (!memory) {
+        const roomId = stringToUuid3(
+          currentTweet.conversationId + "-" + this.runtime.agentId
+        );
+        const userId = stringToUuid3(currentTweet.userId);
+        await this.runtime.ensureConnection(
+          userId,
+          roomId,
+          currentTweet.username,
+          currentTweet.name,
+          "twitter"
+        );
+        this.runtime.messageManager.createMemory({
+          id: stringToUuid3(
+            currentTweet.id + "-" + this.runtime.agentId
+          ),
+          agentId: this.runtime.agentId,
+          content: {
+            text: currentTweet.text,
+            source: "twitter",
+            url: currentTweet.permanentUrl,
+            inReplyTo: currentTweet.inReplyToStatusId ? stringToUuid3(
+              currentTweet.inReplyToStatusId + "-" + this.runtime.agentId
+            ) : void 0
+          },
+          createdAt: currentTweet.timestamp * 1e3,
+          roomId,
+          userId: currentTweet.userId === this.twitterUserId ? this.runtime.agentId : stringToUuid3(currentTweet.userId),
+          embedding: getEmbeddingZeroVector3()
+        });
+      }
+      if (visited.has(currentTweet.id)) {
+        elizaLogger3.log("Already visited tweet:", currentTweet.id);
+        return;
+      }
+      visited.add(currentTweet.id);
+      thread.unshift(currentTweet);
+      elizaLogger3.debug("Current thread state:", {
+        length: thread.length,
+        currentDepth: depth,
+        tweetId: currentTweet.id
+      });
+      if (currentTweet.inReplyToStatusId) {
+        elizaLogger3.log(
+          "Fetching parent tweet:",
+          currentTweet.inReplyToStatusId
+        );
+        try {
+          const parentTweet = await this.twitterClient.getTweet(
+            currentTweet.inReplyToStatusId
+          );
+          if (parentTweet) {
+            elizaLogger3.log("Found parent tweet:", {
+              id: parentTweet.id,
+              text: parentTweet.text?.slice(0, 50)
+            });
+            await processThread(parentTweet, depth + 1);
+          } else {
+            elizaLogger3.log(
+              "No parent tweet found for:",
+              currentTweet.inReplyToStatusId
+            );
+          }
+        } catch (error) {
+          elizaLogger3.log("Error fetching parent tweet:", {
+            tweetId: currentTweet.inReplyToStatusId,
+            error
+          });
+        }
+      } else {
+        elizaLogger3.log(
+          "Reached end of reply chain at:",
+          currentTweet.id
+        );
+      }
+    }
+    await processThread.bind(this)(tweet, 0);
+    elizaLogger3.debug("Final thread built:", {
+      totalTweets: thread.length,
+      tweetIds: thread.map((t) => ({
+        id: t.id,
+        text: t.text?.slice(0, 50)
+      }))
+    });
+    return thread;
+  }
+};
+
+// src/post.ts
+import {
+  composeContext as composeContext2,
+  generateText,
+  getEmbeddingZeroVector as getEmbeddingZeroVector4,
+  ModelClass as ModelClass2,
+  stringToUuid as stringToUuid4,
+  parseBooleanFromText
+} from "@ai16z/eliza";
+import { elizaLogger as elizaLogger4 } from "@ai16z/eliza";
+import { postActionResponseFooter } from "@ai16z/eliza";
+import { generateTweetActions } from "@ai16z/eliza";
+import { ServiceType } from "@ai16z/eliza";
+var twitterPostTemplate = `
+# Areas of Expertise
+{{knowledge}}
+
+# About {{agentName}} (@{{twitterUserName}}):
+{{bio}}
+{{lore}}
+{{topics}}
+
+{{providers}}
+
+{{characterPostExamples}}
+
+{{postDirections}}
+
+# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.
+Write a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.
+Your response should be 1, 2, or 3 sentences (choose the length at random).
+Your response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\n\\n (double spaces) between statements if there are multiple statements in your response.`;
+var twitterActionTemplate = `
+# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:
+{{bio}}
+{{postDirections}}
+
+Guidelines:
+- Highly selective engagement
+- Direct mentions are priority
+- Skip: low-effort content, off-topic, repetitive
+
+Actions (respond only with tags):
+[LIKE] - Resonates with interests (9.5/10)
+[RETWEET] - Perfect character alignment (9/10)
+[QUOTE] - Can add unique value (8/10)
+[REPLY] - Memetic opportunity (9/10)
+
+Tweet:
+{{currentTweet}}
+
+# Respond with qualifying action tags only.` + postActionResponseFooter;
+var MAX_TWEET_LENGTH = 240;
+function truncateToCompleteSentence(text, maxTweetLength) {
+  if (text.length <= maxTweetLength) {
+    return text;
+  }
+  const truncatedAtPeriod = text.slice(
+    0,
+    text.lastIndexOf(".", maxTweetLength) + 1
+  );
+  if (truncatedAtPeriod.trim().length > 0) {
+    return truncatedAtPeriod.trim();
+  }
+  const truncatedAtSpace = text.slice(
+    0,
+    text.lastIndexOf(" ", maxTweetLength)
+  );
+  if (truncatedAtSpace.trim().length > 0) {
+    return truncatedAtSpace.trim() + "...";
+  }
+  return text.slice(0, maxTweetLength - 3).trim() + "...";
+}
+var TwitterPostClient = class {
+  client;
+  runtime;
+  twitterUsername;
+  isProcessing = false;
+  lastProcessTime = 0;
+  stopProcessingActions = false;
+  async start(postImmediately = false) {
+    if (!this.client.profile) {
+      await this.client.init();
+    }
+    const generateNewTweetLoop = async () => {
+      const lastPost = await this.runtime.cacheManager.get("twitter/" + this.twitterUsername + "/lastPost");
+      const lastPostTimestamp = lastPost?.timestamp ?? 0;
+      const minMinutes = parseInt(this.runtime.getSetting("POST_INTERVAL_MIN")) || 90;
+      const maxMinutes = parseInt(this.runtime.getSetting("POST_INTERVAL_MAX")) || 180;
+      const randomMinutes = Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) + minMinutes;
+      const delay = randomMinutes * 60 * 1e3;
+      if (Date.now() > lastPostTimestamp + delay) {
+        await this.generateNewTweet();
+      }
+      setTimeout(() => {
+        generateNewTweetLoop();
+      }, delay);
+      elizaLogger4.log(`Next tweet scheduled in ${randomMinutes} minutes`);
+    };
+    const processActionsLoop = async () => {
+      const actionInterval = parseInt(this.runtime.getSetting("ACTION_INTERVAL")) || 3e5;
+      while (!this.stopProcessingActions) {
+        try {
+          const results = await this.processTweetActions();
+          if (results) {
+            elizaLogger4.log(`Processed ${results.length} tweets`);
+            elizaLogger4.log(
+              `Next action processing scheduled in ${actionInterval / 1e3} seconds`
+            );
+            await new Promise(
+              (resolve) => setTimeout(resolve, actionInterval)
+            );
+          }
+        } catch (error) {
+          elizaLogger4.error(
+            "Error in action processing loop:",
+            error
+          );
+          await new Promise((resolve) => setTimeout(resolve, 3e4));
+        }
+      }
+    };
+    if (this.runtime.getSetting("POST_IMMEDIATELY") != null && this.runtime.getSetting("POST_IMMEDIATELY") != "") {
+      postImmediately = parseBooleanFromText(
+        this.runtime.getSetting("POST_IMMEDIATELY")
+      );
+    }
+    if (postImmediately) {
+      await this.generateNewTweet();
+    }
+    generateNewTweetLoop();
+    const enableActionProcessing = this.runtime.getSetting("ENABLE_ACTION_PROCESSING") ?? false;
+    if (enableActionProcessing) {
+      processActionsLoop().catch((error) => {
+        elizaLogger4.error(
+          "Fatal error in process actions loop:",
+          error
+        );
+      });
+    } else {
+      elizaLogger4.log("Action processing loop disabled by configuration");
+    }
+    generateNewTweetLoop();
+  }
+  constructor(client, runtime) {
+    this.client = client;
+    this.runtime = runtime;
+    this.twitterUsername = runtime.getSetting("TWITTER_USERNAME");
+  }
+  async generateNewTweet() {
+    elizaLogger4.log("Generating new tweet");
+    try {
+      const roomId = stringToUuid4(
+        "twitter_generate_room-" + this.client.profile.username
+      );
+      await this.runtime.ensureUserExists(
+        this.runtime.agentId,
+        this.client.profile.username,
+        this.runtime.character.name,
+        "twitter"
+      );
+      const topics = this.runtime.character.topics.join(", ");
+      const state = await this.runtime.composeState(
+        {
+          userId: this.runtime.agentId,
+          roomId,
+          agentId: this.runtime.agentId,
+          content: {
+            text: topics || "",
+            action: "TWEET"
+          }
+        },
+        {
+          twitterUserName: this.client.profile.username
+        }
+      );
+      const context = composeContext2({
+        state,
+        template: this.runtime.character.templates?.twitterPostTemplate || twitterPostTemplate
+      });
+      console.log("twitter context:\n" + context);
+      elizaLogger4.debug("generate post prompt:\n" + context);
+      const newTweetContent = await generateText({
+        runtime: this.runtime,
+        context,
+        modelClass: ModelClass2.SMALL
+      });
+      let cleanedContent = "";
+      try {
+        const parsedResponse = JSON.parse(newTweetContent);
+        if (parsedResponse.text) {
+          cleanedContent = parsedResponse.text;
+        } else if (typeof parsedResponse === "string") {
+          cleanedContent = parsedResponse;
+        }
+      } catch (error) {
+        error.linted = true;
+        cleanedContent = newTweetContent.replace(/^\s*{?\s*"text":\s*"|"\s*}?\s*$/g, "").replace(/^['"](.*)['"]$/g, "$1").replace(/\\"/g, '"').replace(/\\n/g, "\n").trim();
+      }
+      if (!cleanedContent) {
+        elizaLogger4.error(
+          "Failed to extract valid content from response:",
+          {
+            rawResponse: newTweetContent,
+            attempted: "JSON parsing"
+          }
+        );
+        return;
+      }
+      const content = truncateToCompleteSentence(
+        cleanedContent,
+        MAX_TWEET_LENGTH
+      );
+      const removeQuotes = (str) => str.replace(/^['"](.*)['"]$/, "$1");
+      const fixNewLines = (str) => str.replaceAll(/\\n/g, "\n");
+      cleanedContent = removeQuotes(fixNewLines(content));
+      if (this.runtime.getSetting("TWITTER_DRY_RUN") === "true") {
+        elizaLogger4.info(
+          `Dry run: would have posted tweet: ${cleanedContent}`
+        );
+        return;
+      }
+      try {
+        elizaLogger4.log(`Posting new tweet:
+ ${cleanedContent}`);
+        const result = await this.client.requestQueue.add(
+          async () => await this.client.twitterClient.sendTweet(
+            cleanedContent
+          )
+        );
+        const body = await result.json();
+        if (!body?.data?.create_tweet?.tweet_results?.result) {
+          console.error("Error sending tweet; Bad response:", body);
+          return;
+        }
+        const tweetResult = body.data.create_tweet.tweet_results.result;
+        const tweet = {
+          id: tweetResult.rest_id,
+          name: this.client.profile.screenName,
+          username: this.client.profile.username,
+          text: tweetResult.legacy.full_text,
+          conversationId: tweetResult.legacy.conversation_id_str,
+          createdAt: tweetResult.legacy.created_at,
+          timestamp: new Date(
+            tweetResult.legacy.created_at
+          ).getTime(),
+          userId: this.client.profile.id,
+          inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,
+          permanentUrl: `https://twitter.com/${this.twitterUsername}/status/${tweetResult.rest_id}`,
+          hashtags: [],
+          mentions: [],
+          photos: [],
+          thread: [],
+          urls: [],
+          videos: []
+        };
+        await this.runtime.cacheManager.set(
+          `twitter/${this.client.profile.username}/lastPost`,
+          {
+            id: tweet.id,
+            timestamp: Date.now()
+          }
+        );
+        await this.client.cacheTweet(tweet);
+        elizaLogger4.log(`Tweet posted:
+ ${tweet.permanentUrl}`);
+        await this.runtime.ensureRoomExists(roomId);
+        await this.runtime.ensureParticipantInRoom(
+          this.runtime.agentId,
+          roomId
+        );
+        await this.runtime.messageManager.createMemory({
+          id: stringToUuid4(tweet.id + "-" + this.runtime.agentId),
+          userId: this.runtime.agentId,
+          agentId: this.runtime.agentId,
+          content: {
+            text: newTweetContent.trim(),
+            url: tweet.permanentUrl,
+            source: "twitter"
+          },
+          roomId,
+          embedding: getEmbeddingZeroVector4(),
+          createdAt: tweet.timestamp
+        });
+      } catch (error) {
+        elizaLogger4.error("Error sending tweet:", error);
+      }
+    } catch (error) {
+      elizaLogger4.error("Error generating new tweet:", error);
+    }
+  }
+  async generateTweetContent(tweetState, options) {
+    const context = composeContext2({
+      state: tweetState,
+      template: options?.template || this.runtime.character.templates?.twitterPostTemplate || twitterPostTemplate
+    });
+    const response = await generateText({
+      runtime: this.runtime,
+      context: options?.context || context,
+      modelClass: ModelClass2.SMALL
+    });
+    console.log("generate tweet content response:\n" + response);
+    const cleanedResponse = response.replace(/```json\s*/g, "").replace(/```\s*/g, "").replaceAll(/\\n/g, "\n").trim();
+    try {
+      const jsonResponse = JSON.parse(cleanedResponse);
+      if (jsonResponse.text) {
+        return this.trimTweetLength(jsonResponse.text);
+      }
+      if (typeof jsonResponse === "object") {
+        const possibleContent = jsonResponse.content || jsonResponse.message || jsonResponse.response;
+        if (possibleContent) {
+          return this.trimTweetLength(possibleContent);
+        }
+      }
+    } catch (error) {
+      error.linted = true;
+      elizaLogger4.debug("Response is not JSON, treating as plain text");
+    }
+    return this.trimTweetLength(cleanedResponse);
+  }
+  // Helper method to ensure tweet length compliance
+  trimTweetLength(text, maxLength = 280) {
+    if (text.length <= maxLength) return text;
+    const lastSentence = text.slice(0, maxLength).lastIndexOf(".");
+    if (lastSentence > 0) {
+      return text.slice(0, lastSentence + 1).trim();
+    }
+    return text.slice(0, text.lastIndexOf(" ", maxLength - 3)).trim() + "...";
+  }
+  async processTweetActions() {
+    if (this.isProcessing) {
+      elizaLogger4.log("Already processing tweet actions, skipping");
+      return null;
+    }
+    try {
+      this.isProcessing = true;
+      this.lastProcessTime = Date.now();
+      elizaLogger4.log("Processing tweet actions");
+      await this.runtime.ensureUserExists(
+        this.runtime.agentId,
+        this.twitterUsername,
+        this.runtime.character.name,
+        "twitter"
+      );
+      const homeTimeline = await this.client.fetchTimelineForActions(15);
+      const results = [];
+      for (const tweet of homeTimeline) {
+        try {
+          const memory = await this.runtime.messageManager.getMemoryById(
+            stringToUuid4(tweet.id + "-" + this.runtime.agentId)
+          );
+          if (memory) {
+            elizaLogger4.log(
+              `Already processed tweet ID: ${tweet.id}`
+            );
+            continue;
+          }
+          const roomId = stringToUuid4(
+            tweet.conversationId + "-" + this.runtime.agentId
+          );
+          const tweetState = await this.runtime.composeState(
+            {
+              userId: this.runtime.agentId,
+              roomId,
+              agentId: this.runtime.agentId,
+              content: { text: "", action: "" }
+            },
+            {
+              twitterUserName: this.twitterUsername,
+              currentTweet: `ID: ${tweet.id}
+From: ${tweet.name} (@${tweet.username})
+Text: ${tweet.text}`
+            }
+          );
+          const actionContext = composeContext2({
+            state: tweetState,
+            template: this.runtime.character.templates?.twitterActionTemplate || twitterActionTemplate
+          });
+          const actionResponse = await generateTweetActions({
+            runtime: this.runtime,
+            context: actionContext,
+            modelClass: ModelClass2.SMALL
+          });
+          if (!actionResponse) {
+            elizaLogger4.log(
+              `No valid actions generated for tweet ${tweet.id}`
+            );
+            continue;
+          }
+          const executedActions = [];
+          if (actionResponse.like) {
+            try {
+              await this.client.twitterClient.likeTweet(tweet.id);
+              executedActions.push("like");
+              elizaLogger4.log(`Liked tweet ${tweet.id}`);
+            } catch (error) {
+              elizaLogger4.error(
+                `Error liking tweet ${tweet.id}:`,
+                error
+              );
+            }
+          }
+          if (actionResponse.retweet) {
+            try {
+              await this.client.twitterClient.retweet(tweet.id);
+              executedActions.push("retweet");
+              elizaLogger4.log(`Retweeted tweet ${tweet.id}`);
+            } catch (error) {
+              elizaLogger4.error(
+                `Error retweeting tweet ${tweet.id}:`,
+                error
+              );
+            }
+          }
+          if (actionResponse.quote) {
+            try {
+              const thread = await buildConversationThread(
+                tweet,
+                this.client
+              );
+              const formattedConversation = thread.map(
+                (t) => `@${t.username} (${new Date(t.timestamp * 1e3).toLocaleString()}): ${t.text}`
+              ).join("\n\n");
+              const imageDescriptions = [];
+              if (tweet.photos?.length > 0) {
+                elizaLogger4.log(
+                  "Processing images in tweet for context"
+                );
+                for (const photo of tweet.photos) {
+                  const description = await this.runtime.getService(
+                    ServiceType.IMAGE_DESCRIPTION
+                  ).describeImage(photo.url);
+                  imageDescriptions.push(description);
+                }
+              }
+              let quotedContent = "";
+              if (tweet.quotedStatusId) {
+                try {
+                  const quotedTweet = await this.client.twitterClient.getTweet(
+                    tweet.quotedStatusId
+                  );
+                  if (quotedTweet) {
+                    quotedContent = `
+Quoted Tweet from @${quotedTweet.username}:
+${quotedTweet.text}`;
+                  }
+                } catch (error) {
+                  elizaLogger4.error(
+                    "Error fetching quoted tweet:",
+                    error
+                  );
+                }
+              }
+              const enrichedState = await this.runtime.composeState(
+                {
+                  userId: this.runtime.agentId,
+                  roomId: stringToUuid4(
+                    tweet.conversationId + "-" + this.runtime.agentId
+                  ),
+                  agentId: this.runtime.agentId,
+                  content: {
+                    text: tweet.text,
+                    action: "QUOTE"
+                  }
+                },
+                {
+                  twitterUserName: this.twitterUsername,
+                  currentPost: `From @${tweet.username}: ${tweet.text}`,
+                  formattedConversation,
+                  imageContext: imageDescriptions.length > 0 ? `
+Images in Tweet:
+${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join("\n")}` : "",
+                  quotedContent
+                }
+              );
+              const quoteContent = await this.generateTweetContent(enrichedState, {
+                template: this.runtime.character.templates?.twitterMessageHandlerTemplate || twitterMessageHandlerTemplate
+              });
+              if (!quoteContent) {
+                elizaLogger4.error(
+                  "Failed to generate valid quote tweet content"
+                );
+                return;
+              }
+              elizaLogger4.log(
+                "Generated quote tweet content:",
+                quoteContent
+              );
+              const result = await this.client.requestQueue.add(
+                async () => await this.client.twitterClient.sendQuoteTweet(
+                  quoteContent,
+                  tweet.id
+                )
+              );
+              const body = await result.json();
+              if (body?.data?.create_tweet?.tweet_results?.result) {
+                elizaLogger4.log(
+                  "Successfully posted quote tweet"
+                );
+                executedActions.push("quote");
+                await this.runtime.cacheManager.set(
+                  `twitter/quote_generation_${tweet.id}.txt`,
+                  `Context:
+${enrichedState}
+
+Generated Quote:
+${quoteContent}`
+                );
+              } else {
+                elizaLogger4.error(
+                  "Quote tweet creation failed:",
+                  body
+                );
+              }
+            } catch (error) {
+              elizaLogger4.error(
+                "Error in quote tweet generation:",
+                error
+              );
+            }
+          }
+          if (actionResponse.reply) {
+            try {
+              await this.handleTextOnlyReply(
+                tweet,
+                tweetState,
+                executedActions
+              );
+            } catch (error) {
+              elizaLogger4.error(
+                `Error replying to tweet ${tweet.id}:`,
+                error
+              );
+            }
+          }
+          await this.runtime.ensureRoomExists(roomId);
+          await this.runtime.ensureUserExists(
+            stringToUuid4(tweet.userId),
+            tweet.username,
+            tweet.name,
+            "twitter"
+          );
+          await this.runtime.ensureParticipantInRoom(
+            this.runtime.agentId,
+            roomId
+          );
+          await this.runtime.messageManager.createMemory({
+            id: stringToUuid4(tweet.id + "-" + this.runtime.agentId),
+            userId: stringToUuid4(tweet.userId),
+            content: {
+              text: tweet.text,
+              url: tweet.permanentUrl,
+              source: "twitter",
+              action: executedActions.join(",")
+            },
+            agentId: this.runtime.agentId,
+            roomId,
+            embedding: getEmbeddingZeroVector4(),
+            createdAt: tweet.timestamp * 1e3
+          });
+          results.push({
+            tweetId: tweet.id,
+            parsedActions: actionResponse,
+            executedActions
+          });
+        } catch (error) {
+          elizaLogger4.error(
+            `Error processing tweet ${tweet.id}:`,
+            error
+          );
+          continue;
+        }
+      }
+      return results;
+    } catch (error) {
+      elizaLogger4.error("Error in processTweetActions:", error);
+      throw error;
+    } finally {
+      this.isProcessing = false;
+    }
+  }
+  async handleTextOnlyReply(tweet, tweetState, executedActions) {
+    try {
+      const thread = await buildConversationThread(tweet, this.client);
+      const formattedConversation = thread.map(
+        (t) => `@${t.username} (${new Date(t.timestamp * 1e3).toLocaleString()}): ${t.text}`
+      ).join("\n\n");
+      const imageDescriptions = [];
+      if (tweet.photos?.length > 0) {
+        elizaLogger4.log("Processing images in tweet for context");
+        for (const photo of tweet.photos) {
+          const description = await this.runtime.getService(
+            ServiceType.IMAGE_DESCRIPTION
+          ).describeImage(photo.url);
+          imageDescriptions.push(description);
+        }
+      }
+      let quotedContent = "";
+      if (tweet.quotedStatusId) {
+        try {
+          const quotedTweet = await this.client.twitterClient.getTweet(
+            tweet.quotedStatusId
+          );
+          if (quotedTweet) {
+            quotedContent = `
+Quoted Tweet from @${quotedTweet.username}:
+${quotedTweet.text}`;
+          }
+        } catch (error) {
+          elizaLogger4.error("Error fetching quoted tweet:", error);
+        }
+      }
+      const enrichedState = await this.runtime.composeState(
+        {
+          userId: this.runtime.agentId,
+          roomId: stringToUuid4(
+            tweet.conversationId + "-" + this.runtime.agentId
+          ),
+          agentId: this.runtime.agentId,
+          content: { text: tweet.text, action: "" }
+        },
+        {
+          twitterUserName: this.twitterUsername,
+          currentPost: `From @${tweet.username}: ${tweet.text}`,
+          formattedConversation,
+          imageContext: imageDescriptions.length > 0 ? `
+Images in Tweet:
+${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join("\n")}` : "",
+          quotedContent
+        }
+      );
+      const replyText = await this.generateTweetContent(enrichedState, {
+        template: this.runtime.character.templates?.twitterMessageHandlerTemplate || twitterMessageHandlerTemplate
+      });
+      if (!replyText) {
+        elizaLogger4.error("Failed to generate valid reply content");
+        return;
+      }
+      elizaLogger4.debug("Final reply text to be sent:", replyText);
+      const result = await this.client.requestQueue.add(
+        async () => await this.client.twitterClient.sendTweet(
+          replyText,
+          tweet.id
+        )
+      );
+      const body = await result.json();
+      if (body?.data?.create_tweet?.tweet_results?.result) {
+        elizaLogger4.log("Successfully posted reply tweet");
+        executedActions.push("reply");
+        await this.runtime.cacheManager.set(
+          `twitter/reply_generation_${tweet.id}.txt`,
+          `Context:
+${enrichedState}
+
+Generated Reply:
+${replyText}`
+        );
+      } else {
+        elizaLogger4.error("Tweet reply creation failed:", body);
+      }
+    } catch (error) {
+      elizaLogger4.error("Error in handleTextOnlyReply:", error);
+    }
+  }
+  async stop() {
+    this.stopProcessingActions = true;
+  }
+};
+
+// src/search.ts
+import { SearchMode as SearchMode3 } from "agent-twitter-client";
+import { composeContext as composeContext3 } from "@ai16z/eliza";
+import { generateMessageResponse as generateMessageResponse2, generateText as generateText2 } from "@ai16z/eliza";
+import { messageCompletionFooter as messageCompletionFooter2 } from "@ai16z/eliza";
+import {
+  ModelClass as ModelClass3,
+  ServiceType as ServiceType2
+} from "@ai16z/eliza";
+import { stringToUuid as stringToUuid5 } from "@ai16z/eliza";
+var twitterSearchTemplate = `{{timeline}}
+
+{{providers}}
+
+Recent interactions between {{agentName}} and other users:
+{{recentPostInteractions}}
+
+About {{agentName}} (@{{twitterUserName}}):
+{{bio}}
+{{lore}}
+{{topics}}
+
+{{postDirections}}
+
+{{recentPosts}}
+
+# Task: Respond to the following post in the style and perspective of {{agentName}} (aka @{{twitterUserName}}). Write a {{adjective}} response for {{agentName}} to say directly in response to the post. don't generalize.
+{{currentPost}}
+
+IMPORTANT: Your response CANNOT be longer than 20 words.
+Aim for 1-2 short sentences maximum. Be concise and direct.
+
+Your response should not contain any questions. Brief, concise statements only. No emojis. Use \\n\\n (double spaces) between statements.
+
+` + messageCompletionFooter2;
+var TwitterSearchClient = class {
+  client;
+  runtime;
+  twitterUsername;
+  respondedTweets = /* @__PURE__ */ new Set();
+  constructor(client, runtime) {
+    this.client = client;
+    this.runtime = runtime;
+    this.twitterUsername = runtime.getSetting("TWITTER_USERNAME");
+  }
+  async start() {
+    this.engageWithSearchTermsLoop();
+  }
+  engageWithSearchTermsLoop() {
+    this.engageWithSearchTerms();
+    setTimeout(
+      () => this.engageWithSearchTermsLoop(),
+      (Math.floor(Math.random() * (120 - 60 + 1)) + 60) * 60 * 1e3
+    );
+  }
+  async engageWithSearchTerms() {
+    console.log("Engaging with search terms");
+    try {
+      const searchTerm = [...this.runtime.character.topics][Math.floor(Math.random() * this.runtime.character.topics.length)];
+      console.log("Fetching search tweets");
+      await new Promise((resolve) => setTimeout(resolve, 5e3));
+      const recentTweets = await this.client.fetchSearchTweets(
+        searchTerm,
+        20,
+        SearchMode3.Top
+      );
+      console.log("Search tweets fetched");
+      const homeTimeline = await this.client.fetchHomeTimeline(50);
+      await this.client.cacheTimeline(homeTimeline);
+      const formattedHomeTimeline = `# ${this.runtime.character.name}'s Home Timeline
+
+` + homeTimeline.map((tweet) => {
+        return `ID: ${tweet.id}
+From: ${tweet.name} (@${tweet.username})${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : ""}
+Text: ${tweet.text}
+---
+`;
+      }).join("\n");
+      const slicedTweets = recentTweets.tweets.sort(() => Math.random() - 0.5).slice(0, 20);
+      if (slicedTweets.length === 0) {
+        console.log(
+          "No valid tweets found for the search term",
+          searchTerm
+        );
+        return;
+      }
+      const prompt = `
+  Here are some tweets related to the search term "${searchTerm}":
+
+  ${[...slicedTweets, ...homeTimeline].filter((tweet) => {
+        const thread = tweet.thread;
+        const botTweet = thread.find(
+          (t) => t.username === this.twitterUsername
+        );
+        return !botTweet;
+      }).map(
+        (tweet) => `
+    ID: ${tweet.id}${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : ""}
+    From: ${tweet.name} (@${tweet.username})
+    Text: ${tweet.text}
+  `
+      ).join("\n")}
+
+  Which tweet is the most interesting and relevant for Ruby to reply to? Please provide only the ID of the tweet in your response.
+  Notes:
+    - Respond to English tweets only
+    - Respond to tweets that don't have a lot of hashtags, links, URLs or images
+    - Respond to tweets that are not retweets
+    - Respond to tweets where there is an easy exchange of ideas to have with the user
+    - ONLY respond with the ID of the tweet`;
+      const mostInterestingTweetResponse = await generateText2({
+        runtime: this.runtime,
+        context: prompt,
+        modelClass: ModelClass3.SMALL
+      });
+      const tweetId = mostInterestingTweetResponse.trim();
+      const selectedTweet = slicedTweets.find(
+        (tweet) => tweet.id.toString().includes(tweetId) || tweetId.includes(tweet.id.toString())
+      );
+      if (!selectedTweet) {
+        console.log("No matching tweet found for the selected ID");
+        return console.log("Selected tweet ID:", tweetId);
+      }
+      console.log("Selected tweet to reply to:", selectedTweet?.text);
+      if (selectedTweet.username === this.twitterUsername) {
+        console.log("Skipping tweet from bot itself");
+        return;
+      }
+      const conversationId = selectedTweet.conversationId;
+      const roomId = stringToUuid5(
+        conversationId + "-" + this.runtime.agentId
+      );
+      const userIdUUID = stringToUuid5(selectedTweet.userId);
+      await this.runtime.ensureConnection(
+        userIdUUID,
+        roomId,
+        selectedTweet.username,
+        selectedTweet.name,
+        "twitter"
+      );
+      await buildConversationThread(selectedTweet, this.client);
+      const message = {
+        id: stringToUuid5(selectedTweet.id + "-" + this.runtime.agentId),
+        agentId: this.runtime.agentId,
+        content: {
+          text: selectedTweet.text,
+          url: selectedTweet.permanentUrl,
+          inReplyTo: selectedTweet.inReplyToStatusId ? stringToUuid5(
+            selectedTweet.inReplyToStatusId + "-" + this.runtime.agentId
+          ) : void 0
+        },
+        userId: userIdUUID,
+        roomId,
+        // Timestamps are in seconds, but we need them in milliseconds
+        createdAt: selectedTweet.timestamp * 1e3
+      };
+      if (!message.content.text) {
+        return { text: "", action: "IGNORE" };
+      }
+      const replies = selectedTweet.thread;
+      const replyContext = replies.filter((reply) => reply.username !== this.twitterUsername).map((reply) => `@${reply.username}: ${reply.text}`).join("\n");
+      let tweetBackground = "";
+      if (selectedTweet.isRetweet) {
+        const originalTweet = await this.client.requestQueue.add(
+          () => this.client.twitterClient.getTweet(selectedTweet.id)
+        );
+        tweetBackground = `Retweeting @${originalTweet.username}: ${originalTweet.text}`;
+      }
+      const imageDescriptions = [];
+      for (const photo of selectedTweet.photos) {
+        const description = await this.runtime.getService(
+          ServiceType2.IMAGE_DESCRIPTION
+        ).describeImage(photo.url);
+        imageDescriptions.push(description);
+      }
+      let state = await this.runtime.composeState(message, {
+        twitterClient: this.client.twitterClient,
+        twitterUserName: this.twitterUsername,
+        timeline: formattedHomeTimeline,
+        tweetContext: `${tweetBackground}
+
+  Original Post:
+  By @${selectedTweet.username}
+  ${selectedTweet.text}${replyContext.length > 0 && `
+Replies to original post:
+${replyContext}`}
+  ${`Original post text: ${selectedTweet.text}`}
+  ${selectedTweet.urls.length > 0 ? `URLs: ${selectedTweet.urls.join(", ")}
+` : ""}${imageDescriptions.length > 0 ? `
+Images in Post (Described): ${imageDescriptions.join(", ")}
+` : ""}
+  `
+      });
+      await this.client.saveRequestMessage(message, state);
+      const context = composeContext3({
+        state,
+        template: this.runtime.character.templates?.twitterSearchTemplate || twitterSearchTemplate
+      });
+      const responseContent = await generateMessageResponse2({
+        runtime: this.runtime,
+        context,
+        modelClass: ModelClass3.LARGE
+      });
+      responseContent.inReplyTo = message.id;
+      const response = responseContent;
+      if (!response.text) {
+        console.log("Returning: No response text found");
+        return;
+      }
+      console.log(
+        `Bot would respond to tweet ${selectedTweet.id} with: ${response.text}`
+      );
+      try {
+        const callback = async (response2) => {
+          const memories = await sendTweet(
+            this.client,
+            response2,
+            message.roomId,
+            this.twitterUsername,
+            tweetId
+          );
+          return memories;
+        };
+        const responseMessages = await callback(responseContent);
+        state = await this.runtime.updateRecentMessageState(state);
+        for (const responseMessage of responseMessages) {
+          await this.runtime.messageManager.createMemory(
+            responseMessage,
+            false
+          );
+        }
+        state = await this.runtime.updateRecentMessageState(state);
+        await this.runtime.evaluate(message, state);
+        await this.runtime.processActions(
+          message,
+          responseMessages,
+          state,
+          callback
+        );
+        this.respondedTweets.add(selectedTweet.id);
+        const responseInfo = `Context:
+
+${context}
+
+Selected Post: ${selectedTweet.id} - ${selectedTweet.username}: ${selectedTweet.text}
+Agent's Output:
+${response.text}`;
+        await this.runtime.cacheManager.set(
+          `twitter/tweet_generation_${selectedTweet.id}.txt`,
+          responseInfo
+        );
+        await wait();
+      } catch (error) {
+        console.error(`Error sending response post: ${error}`);
+      }
+    } catch (error) {
+      console.error("Error engaging with search terms:", error);
+    }
+  }
+};
+
+// src/index.ts
+var TwitterManager = class {
+  client;
+  post;
+  search;
+  interaction;
+  constructor(runtime, enableSearch) {
+    this.client = new ClientBase(runtime);
+    this.post = new TwitterPostClient(this.client, runtime);
+    if (enableSearch) {
+      elizaLogger5.warn("Twitter/X client running in a mode that:");
+      elizaLogger5.warn("1. violates consent of random users");
+      elizaLogger5.warn("2. burns your rate limit");
+      elizaLogger5.warn("3. can get your account banned");
+      elizaLogger5.warn("use at your own risk");
+      this.search = new TwitterSearchClient(this.client, runtime);
+    }
+    this.interaction = new TwitterInteractionClient(this.client, runtime);
+  }
+};
+var TwitterClientInterface = {
+  async start(runtime) {
+    await validateTwitterConfig(runtime);
+    elizaLogger5.log("Twitter client started");
+    const manager = new TwitterManager(runtime, this.enableSearch);
+    await manager.client.init();
+    await manager.post.start();
+    await manager.interaction.start();
+    await manager.search?.start();
+    return manager;
+  },
+  async stop(_runtime) {
+    elizaLogger5.warn("Twitter client does not support stopping yet");
+  }
+};
+var src_default = TwitterClientInterface;
+export {
+  TwitterClientInterface,
+  src_default as default
+};
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff -Naur node_modules/@ai16z/client-twitter.original/dist/index.js.map node_modules/@ai16z/client-twitter/dist/index.js.map
--- node_modules/@ai16z/client-twitter.original/dist/index.js.map	1969-12-31 20:00:00.000000000 -0400
+++ node_modules/@ai16z/client-twitter/dist/index.js.map	2025-01-12 20:44:04.768893881 -0400
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/index.ts","../src/base.ts","../src/environment.ts","../src/interactions.ts","../src/utils.ts","../src/post.ts","../src/search.ts"],"sourcesContent":["import { Client, elizaLogger, IAgentRuntime } from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base.ts\";\nimport { validateTwitterConfig } from \"./environment.ts\";\nimport { TwitterInteractionClient } from \"./interactions.ts\";\nimport { TwitterPostClient } from \"./post.ts\";\nimport { TwitterSearchClient } from \"./search.ts\";\n\nclass TwitterManager {\n    client: ClientBase;\n    post: TwitterPostClient;\n    search: TwitterSearchClient;\n    interaction: TwitterInteractionClient;\n    constructor(runtime: IAgentRuntime, enableSearch: boolean) {\n        this.client = new ClientBase(runtime);\n        this.post = new TwitterPostClient(this.client, runtime);\n\n        if (enableSearch) {\n            // this searches topics from character file\n            elizaLogger.warn(\"Twitter/X client running in a mode that:\");\n            elizaLogger.warn(\"1. violates consent of random users\");\n            elizaLogger.warn(\"2. burns your rate limit\");\n            elizaLogger.warn(\"3. can get your account banned\");\n            elizaLogger.warn(\"use at your own risk\");\n            this.search = new TwitterSearchClient(this.client, runtime);\n        }\n\n        this.interaction = new TwitterInteractionClient(this.client, runtime);\n    }\n}\n\nexport const TwitterClientInterface: Client = {\n    async start(runtime: IAgentRuntime) {\n        await validateTwitterConfig(runtime);\n\n        elizaLogger.log(\"Twitter client started\");\n\n        const manager = new TwitterManager(runtime, this.enableSearch);\n\n        await manager.client.init();\n\n        await manager.post.start();\n\n        await manager.interaction.start();\n\n        await manager.search?.start();\n\n        return manager;\n    },\n    async stop(_runtime: IAgentRuntime) {\n        elizaLogger.warn(\"Twitter client does not support stopping yet\");\n    },\n};\n\nexport default TwitterClientInterface;\n","import {\n    Content,\n    IAgentRuntime,\n    IImageDescriptionService,\n    Memory,\n    State,\n    UUID,\n    getEmbeddingZeroVector,\n    elizaLogger,\n    stringToUuid,\n} from \"@ai16z/eliza\";\nimport {\n    QueryTweetsResponse,\n    Scraper,\n    SearchMode,\n    Tweet,\n} from \"agent-twitter-client\";\nimport { EventEmitter } from \"events\";\n\nexport function extractAnswer(text: string): string {\n    const startIndex = text.indexOf(\"Answer: \") + 8;\n    const endIndex = text.indexOf(\"<|endoftext|>\", 11);\n    return text.slice(startIndex, endIndex);\n}\n\ntype TwitterProfile = {\n    id: string;\n    username: string;\n    screenName: string;\n    bio: string;\n    nicknames: string[];\n};\n\nclass RequestQueue {\n    private queue: (() => Promise<any>)[] = [];\n    private processing: boolean = false;\n\n    async add<T>(request: () => Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.queue.push(async () => {\n                try {\n                    const result = await request();\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            this.processQueue();\n        });\n    }\n\n    private async processQueue(): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const request = this.queue.shift()!;\n            try {\n                await request();\n            } catch (error) {\n                console.error(\"Error processing request:\", error);\n                this.queue.unshift(request);\n                await this.exponentialBackoff(this.queue.length);\n            }\n            await this.randomDelay();\n        }\n\n        this.processing = false;\n    }\n\n    private async exponentialBackoff(retryCount: number): Promise<void> {\n        const delay = Math.pow(2, retryCount) * 1000;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n\n    private async randomDelay(): Promise<void> {\n        const delay = Math.floor(Math.random() * 2000) + 1500;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n}\n\nexport class ClientBase extends EventEmitter {\n    static _twitterClients: { [accountIdentifier: string]: Scraper } = {};\n    twitterClient: Scraper;\n    runtime: IAgentRuntime;\n    directions: string;\n    lastCheckedTweetId: bigint | null = null;\n    imageDescriptionService: IImageDescriptionService;\n    temperature: number = 0.5;\n\n    requestQueue: RequestQueue = new RequestQueue();\n\n    profile: TwitterProfile | null;\n\n    async cacheTweet(tweet: Tweet): Promise<void> {\n        if (!tweet) {\n            console.warn(\"Tweet is undefined, skipping cache\");\n            return;\n        }\n\n        this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);\n    }\n\n    async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {\n        const cached = await this.runtime.cacheManager.get<Tweet>(\n            `twitter/tweets/${tweetId}`\n        );\n\n        return cached;\n    }\n\n    async getTweet(tweetId: string): Promise<Tweet> {\n        const cachedTweet = await this.getCachedTweet(tweetId);\n\n        if (cachedTweet) {\n            return cachedTweet;\n        }\n\n        const tweet = await this.requestQueue.add(() =>\n            this.twitterClient.getTweet(tweetId)\n        );\n\n        await this.cacheTweet(tweet);\n        return tweet;\n    }\n\n    callback: (self: ClientBase) => any = null;\n\n    onReady() {\n        throw new Error(\n            \"Not implemented in base class, please call from subclass\"\n        );\n    }\n\n    constructor(runtime: IAgentRuntime) {\n        super();\n        this.runtime = runtime;\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\n        if (ClientBase._twitterClients[username]) {\n            this.twitterClient = ClientBase._twitterClients[username];\n        } else {\n            this.twitterClient = new Scraper();\n            ClientBase._twitterClients[username] = this.twitterClient;\n        }\n\n        this.directions =\n            \"- \" +\n            this.runtime.character.style.all.join(\"\\n- \") +\n            \"- \" +\n            this.runtime.character.style.post.join();\n    }\n\n    async init() {\n        //test\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\n        const password = this.runtime.getSetting(\"TWITTER_PASSWORD\");\n        const email = this.runtime.getSetting(\"TWITTER_EMAIL\");\n        let retries = parseInt(\n            this.runtime.getSetting(\"TWITTER_RETRY_LIMIT\") || \"5\",\n            10\n        );\n        const twitter2faSecret =\n            this.runtime.getSetting(\"TWITTER_2FA_SECRET\") || undefined;\n        const cookies = this.runtime.getSetting(\"TWITTER_COOKIES\");\n\n        if (!username) {\n            throw new Error(\"Twitter username not configured\");\n        }\n        // Check for Twitter cookies\n        if (cookies) {\n            elizaLogger.debug(\"Using cookies from settings\");\n            const cookiesArray = JSON.parse(cookies);\n\n            await this.setCookiesFromArray(cookiesArray);\n        } else {\n            elizaLogger.debug(\"No cookies found in settings\");\n            elizaLogger.debug(\"Checking for cached cookies\");\n            const cachedCookies = await this.getCachedCookies(username);\n            if (cachedCookies) {\n                await this.setCookiesFromArray(cachedCookies);\n            }\n        }\n\n        elizaLogger.log(\"Waiting for Twitter login\");\n        while (retries > 0) {\n            const cookies = await this.twitterClient.getCookies();\n            if ((await this.twitterClient.isLoggedIn()) && !!cookies) {\n                elizaLogger.info(\"Already logged in.\");\n                await this.cacheCookies(username, cookies);\n                elizaLogger.info(\"Successfully logged in and cookies cached.\");\n                break;\n            }\n\n            try {\n                await this.twitterClient.login(\n                    username,\n                    password,\n                    email,\n                    twitter2faSecret\n                );\n            } catch (error) {\n                elizaLogger.error(`Login attempt failed: ${error.message}`);\n            }\n\n            retries--;\n            elizaLogger.error(\n                `Failed to login to Twitter. Retrying... (${retries} attempts left)`\n            );\n\n            if (retries === 0) {\n                elizaLogger.error(\n                    \"Max retries reached. Exiting login process.\"\n                );\n                throw new Error(\"Twitter login failed after maximum retries.\");\n            }\n\n            await new Promise((resolve) => setTimeout(resolve, 2000));\n        }\n        // Initialize Twitter profile\n        this.profile = await this.fetchProfile(username);\n\n        if (this.profile) {\n            elizaLogger.log(\"Twitter user ID:\", this.profile.id);\n            elizaLogger.log(\n                \"Twitter loaded:\",\n                JSON.stringify(this.profile, null, 10)\n            );\n            // Store profile info for use in responses\n            this.runtime.character.twitterProfile = {\n                id: this.profile.id,\n                username: this.profile.username,\n                screenName: this.profile.screenName,\n                bio: this.profile.bio,\n                nicknames: this.profile.nicknames,\n            };\n        } else {\n            throw new Error(\"Failed to load profile\");\n        }\n\n        await this.loadLatestCheckedTweetId();\n        await this.populateTimeline();\n    }\n\n    async fetchOwnPosts(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching own posts\");\n        const homeTimeline = await this.twitterClient.getUserTweets(\n            this.profile.id,\n            count\n        );\n        return homeTimeline.tweets;\n    }\n\n    async fetchHomeTimeline(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching home timeline\");\n        const homeTimeline = await this.twitterClient.fetchHomeTimeline(\n            count,\n            []\n        );\n\n        elizaLogger.debug(homeTimeline, { depth: Infinity });\n        const processedTimeline = homeTimeline\n            .filter((t) => t.__typename !== \"TweetWithVisibilityResults\") // what's this about?\n            .map((tweet) => {\n                //console.log(\"tweet is\", tweet);\n                const obj = {\n                    id: tweet.id,\n                    name:\n                        tweet.name ?? tweet?.user_results?.result?.legacy.name,\n                    username:\n                        tweet.username ??\n                        tweet.core?.user_results?.result?.legacy.screen_name,\n                    text: tweet.text ?? tweet.legacy?.full_text,\n                    inReplyToStatusId:\n                        tweet.inReplyToStatusId ??\n                        tweet.legacy?.in_reply_to_status_id_str ??\n                        null,\n                    timestamp:\n                        new Date(tweet.legacy?.created_at).getTime() / 1000,\n                    createdAt:\n                        tweet.createdAt ??\n                        tweet.legacy?.created_at ??\n                        tweet.core?.user_results?.result?.legacy.created_at,\n                    userId: tweet.userId ?? tweet.legacy?.user_id_str,\n                    conversationId:\n                        tweet.conversationId ??\n                        tweet.legacy?.conversation_id_str,\n                    permanentUrl: `https://x.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,\n                    hashtags: tweet.hashtags ?? tweet.legacy?.entities.hashtags,\n                    mentions:\n                        tweet.mentions ?? tweet.legacy?.entities.user_mentions,\n                    photos:\n                        tweet.photos ??\n                        tweet.legacy?.entities.media?.filter(\n                            (media) => media.type === \"photo\"\n                        ) ??\n                        [],\n                    thread: tweet.thread || [],\n                    urls: tweet.urls ?? tweet.legacy?.entities.urls,\n                    videos:\n                        tweet.videos ??\n                        tweet.legacy?.entities.media?.filter(\n                            (media) => media.type === \"video\"\n                        ) ??\n                        [],\n                };\n                //console.log(\"obj is\", obj);\n                return obj;\n            });\n        //elizaLogger.debug(\"process homeTimeline\", processedTimeline);\n        return processedTimeline;\n    }\n\n    async fetchTimelineForActions(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching timeline for actions\");\n        const homeTimeline = await this.twitterClient.fetchHomeTimeline(\n            count,\n            []\n        );\n\n        return homeTimeline.map((tweet) => ({\n            id: tweet.rest_id,\n            name: tweet.core?.user_results?.result?.legacy?.name,\n            username: tweet.core?.user_results?.result?.legacy?.screen_name,\n            text: tweet.legacy?.full_text,\n            inReplyToStatusId: tweet.legacy?.in_reply_to_status_id_str,\n            timestamp: new Date(tweet.legacy?.created_at).getTime() / 1000,\n            userId: tweet.legacy?.user_id_str,\n            conversationId: tweet.legacy?.conversation_id_str,\n            permanentUrl: `https://twitter.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,\n            hashtags: tweet.legacy?.entities?.hashtags || [],\n            mentions: tweet.legacy?.entities?.user_mentions || [],\n            photos:\n                tweet.legacy?.entities?.media?.filter(\n                    (media) => media.type === \"photo\"\n                ) || [],\n            thread: tweet.thread || [],\n            urls: tweet.legacy?.entities?.urls || [],\n            videos:\n                tweet.legacy?.entities?.media?.filter(\n                    (media) => media.type === \"video\"\n                ) || [],\n        }));\n    }\n\n    async fetchSearchTweets(\n        query: string,\n        maxTweets: number,\n        searchMode: SearchMode,\n        cursor?: string\n    ): Promise<QueryTweetsResponse> {\n        try {\n            // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\n            // if we dont get a response in 5 seconds, something is wrong\n            const timeoutPromise = new Promise((resolve) =>\n                setTimeout(() => resolve({ tweets: [] }), 10000)\n            );\n\n            try {\n                const result = await this.requestQueue.add(\n                    async () =>\n                        await Promise.race([\n                            this.twitterClient.fetchSearchTweets(\n                                query,\n                                maxTweets,\n                                searchMode,\n                                cursor\n                            ),\n                            timeoutPromise,\n                        ])\n                );\n                return (result ?? { tweets: [] }) as QueryTweetsResponse;\n            } catch (error) {\n                elizaLogger.error(\"Error fetching search tweets:\", error);\n                return { tweets: [] };\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error fetching search tweets:\", error);\n            return { tweets: [] };\n        }\n    }\n\n    private async populateTimeline() {\n        elizaLogger.debug(\"populating timeline...\");\n\n        const cachedTimeline = await this.getCachedTimeline();\n\n        // Check if the cache file exists\n        if (cachedTimeline) {\n            // Read the cached search results from the file\n\n            // Get the existing memories from the database\n            const existingMemories =\n                await this.runtime.messageManager.getMemoriesByRoomIds({\n                    roomIds: cachedTimeline.map((tweet) =>\n                        stringToUuid(\n                            tweet.conversationId + \"-\" + this.runtime.agentId\n                        )\n                    ),\n                });\n\n            //TODO: load tweets not in cache?\n\n            // Create a Set to store the IDs of existing memories\n            const existingMemoryIds = new Set(\n                existingMemories.map((memory) => memory.id.toString())\n            );\n\n            // Check if any of the cached tweets exist in the existing memories\n            const someCachedTweetsExist = cachedTimeline.some((tweet) =>\n                existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n            );\n\n            if (someCachedTweetsExist) {\n                // Filter out the cached tweets that already exist in the database\n                const tweetsToSave = cachedTimeline.filter(\n                    (tweet) =>\n                        !existingMemoryIds.has(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        )\n                );\n\n                console.log({\n                    processingTweets: tweetsToSave\n                        .map((tweet) => tweet.id)\n                        .join(\",\"),\n                });\n\n                // Save the missing tweets as memories\n                for (const tweet of tweetsToSave) {\n                    elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userId =\n                        tweet.userId === this.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId);\n\n                    if (tweet.userId === this.profile.id) {\n                        await this.runtime.ensureConnection(\n                            this.runtime.agentId,\n                            roomId,\n                            this.profile.username,\n                            this.profile.screenName,\n                            \"twitter\"\n                        );\n                    } else {\n                        await this.runtime.ensureConnection(\n                            userId,\n                            roomId,\n                            tweet.username,\n                            tweet.name,\n                            \"twitter\"\n                        );\n                    }\n\n                    const content = {\n                        text: tweet.text,\n                        url: tweet.permanentUrl,\n                        source: \"twitter\",\n                        inReplyTo: tweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  tweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    } as Content;\n\n                    elizaLogger.log(\"Creating memory for tweet\", tweet.id);\n\n                    // check if it already exists\n                    const memory =\n                        await this.runtime.messageManager.getMemoryById(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        );\n\n                    if (memory) {\n                        elizaLogger.log(\n                            \"Memory already exists, skipping timeline population\"\n                        );\n                        break;\n                    }\n\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId,\n                        content: content,\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n\n                    await this.cacheTweet(tweet);\n                }\n\n                elizaLogger.log(\n                    `Populated ${tweetsToSave.length} missing tweets from the cache.`\n                );\n                return;\n            }\n        }\n\n        const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\n\n        // Get the most recent 20 mentions and interactions\n        const mentionsAndInteractions = await this.fetchSearchTweets(\n            `@${username}`,\n            20,\n            SearchMode.Latest\n        );\n\n        // Combine the timeline tweets and mentions/interactions\n        const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\n\n        // Create a Set to store unique tweet IDs\n        const tweetIdsToCheck = new Set<string>();\n        const roomIds = new Set<UUID>();\n\n        // Add tweet IDs to the Set\n        for (const tweet of allTweets) {\n            tweetIdsToCheck.add(tweet.id);\n            roomIds.add(\n                stringToUuid(tweet.conversationId + \"-\" + this.runtime.agentId)\n            );\n        }\n\n        // Check the existing memories in the database\n        const existingMemories =\n            await this.runtime.messageManager.getMemoriesByRoomIds({\n                roomIds: Array.from(roomIds),\n            });\n\n        // Create a Set to store the existing memory IDs\n        const existingMemoryIds = new Set<UUID>(\n            existingMemories.map((memory) => memory.id)\n        );\n\n        // Filter out the tweets that already exist in the database\n        const tweetsToSave = allTweets.filter(\n            (tweet) =>\n                !existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n        );\n\n        elizaLogger.debug({\n            processingTweets: tweetsToSave.map((tweet) => tweet.id).join(\",\"),\n        });\n\n        await this.runtime.ensureUserExists(\n            this.runtime.agentId,\n            this.profile.username,\n            this.runtime.character.name,\n            \"twitter\"\n        );\n\n        // Save the new tweets as memories\n        for (const tweet of tweetsToSave) {\n            elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n            const roomId = stringToUuid(\n                tweet.conversationId + \"-\" + this.runtime.agentId\n            );\n            const userId =\n                tweet.userId === this.profile.id\n                    ? this.runtime.agentId\n                    : stringToUuid(tweet.userId);\n\n            if (tweet.userId === this.profile.id) {\n                await this.runtime.ensureConnection(\n                    this.runtime.agentId,\n                    roomId,\n                    this.profile.username,\n                    this.profile.screenName,\n                    \"twitter\"\n                );\n            } else {\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    tweet.username,\n                    tweet.name,\n                    \"twitter\"\n                );\n            }\n\n            const content = {\n                text: tweet.text,\n                url: tweet.permanentUrl,\n                source: \"twitter\",\n                inReplyTo: tweet.inReplyToStatusId\n                    ? stringToUuid(tweet.inReplyToStatusId)\n                    : undefined,\n            } as Content;\n\n            await this.runtime.messageManager.createMemory({\n                id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                userId,\n                content: content,\n                agentId: this.runtime.agentId,\n                roomId,\n                embedding: getEmbeddingZeroVector(),\n                createdAt: tweet.timestamp * 1000,\n            });\n\n            await this.cacheTweet(tweet);\n        }\n\n        // Cache\n        await this.cacheTimeline(timeline);\n        await this.cacheMentions(mentionsAndInteractions.tweets);\n    }\n\n    async setCookiesFromArray(cookiesArray: any[]) {\n        const cookieStrings = cookiesArray.map(\n            (cookie) =>\n                `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${\n                    cookie.secure ? \"Secure\" : \"\"\n                }; ${cookie.httpOnly ? \"HttpOnly\" : \"\"}; SameSite=${\n                    cookie.sameSite || \"Lax\"\n                }`\n        );\n        await this.twitterClient.setCookies(cookieStrings);\n    }\n\n    async saveRequestMessage(message: Memory, state: State) {\n        if (message.content.text) {\n            const recentMessage = await this.runtime.messageManager.getMemories(\n                {\n                    roomId: message.roomId,\n                    count: 1,\n                    unique: false,\n                }\n            );\n\n            if (\n                recentMessage.length > 0 &&\n                recentMessage[0].content === message.content\n            ) {\n                elizaLogger.debug(\"Message already saved\", recentMessage[0].id);\n            } else {\n                await this.runtime.messageManager.createMemory({\n                    ...message,\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            await this.runtime.evaluate(message, {\n                ...state,\n                twitterClient: this.twitterClient,\n            });\n        }\n    }\n\n    async loadLatestCheckedTweetId(): Promise<void> {\n        const latestCheckedTweetId =\n            await this.runtime.cacheManager.get<string>(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`\n            );\n\n        if (latestCheckedTweetId) {\n            this.lastCheckedTweetId = BigInt(latestCheckedTweetId);\n        }\n    }\n\n    async cacheLatestCheckedTweetId() {\n        if (this.lastCheckedTweetId) {\n            await this.runtime.cacheManager.set(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`,\n                this.lastCheckedTweetId.toString()\n            );\n        }\n    }\n\n    async getCachedTimeline(): Promise<Tweet[] | undefined> {\n        return await this.runtime.cacheManager.get<Tweet[]>(\n            `twitter/${this.profile.username}/timeline`\n        );\n    }\n\n    async cacheTimeline(timeline: Tweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/timeline`,\n            timeline,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async cacheMentions(mentions: Tweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/mentions`,\n            mentions,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async getCachedCookies(username: string) {\n        return await this.runtime.cacheManager.get<any[]>(\n            `twitter/${username}/cookies`\n        );\n    }\n\n    async cacheCookies(username: string, cookies: any[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${username}/cookies`,\n            cookies\n        );\n    }\n\n    async getCachedProfile(username: string) {\n        return await this.runtime.cacheManager.get<TwitterProfile>(\n            `twitter/${username}/profile`\n        );\n    }\n\n    async cacheProfile(profile: TwitterProfile) {\n        await this.runtime.cacheManager.set(\n            `twitter/${profile.username}/profile`,\n            profile\n        );\n    }\n\n    async fetchProfile(username: string): Promise<TwitterProfile> {\n        const cached = await this.getCachedProfile(username);\n\n        if (cached) return cached;\n\n        try {\n            const profile = await this.requestQueue.add(async () => {\n                const profile = await this.twitterClient.getProfile(username);\n                // console.log({ profile });\n                return {\n                    id: profile.userId,\n                    username,\n                    screenName: profile.name || this.runtime.character.name,\n                    bio:\n                        profile.biography ||\n                        typeof this.runtime.character.bio === \"string\"\n                            ? (this.runtime.character.bio as string)\n                            : this.runtime.character.bio.length > 0\n                              ? this.runtime.character.bio[0]\n                              : \"\",\n                    nicknames:\n                        this.runtime.character.twitterProfile?.nicknames || [],\n                } satisfies TwitterProfile;\n            });\n\n            this.cacheProfile(profile);\n\n            return profile;\n        } catch (error) {\n            console.error(\"Error fetching Twitter profile:\", error);\n\n            return undefined;\n        }\n    }\n}\n","import { IAgentRuntime } from \"@ai16z/eliza\";\nimport { z } from \"zod\";\n\nexport const DEFAULT_MAX_TWEET_LENGTH = 280;\n\nexport const twitterEnvSchema = z.object({\n    TWITTER_DRY_RUN: z\n        .string()\n        .transform((val) => val.toLowerCase() === \"true\"),\n    TWITTER_USERNAME: z.string().min(1, \"Twitter username is required\"),\n    TWITTER_PASSWORD: z.string().min(1, \"Twitter password is required\"),\n    TWITTER_EMAIL: z.string().email(\"Valid Twitter email is required\"),\n    TWITTER_COOKIES: z.string().optional(),\n    MAX_TWEET_LENGTH: z\n        .string()\n        .pipe(z.coerce.number().min(0).int())\n        .default(DEFAULT_MAX_TWEET_LENGTH.toString()),\n});\n\nexport type TwitterConfig = z.infer<typeof twitterEnvSchema>;\n\nexport async function validateTwitterConfig(\n    runtime: IAgentRuntime\n): Promise<TwitterConfig> {\n    try {\n        const twitterConfig = {\n            TWITTER_DRY_RUN:\n                runtime.getSetting(\"TWITTER_DRY_RUN\") ||\n                process.env.TWITTER_DRY_RUN ||\n                \"false\",\n            TWITTER_USERNAME:\n                runtime.getSetting(\"TWITTER_USERNAME\") ||\n                process.env.TWITTER_USERNAME,\n            TWITTER_PASSWORD:\n                runtime.getSetting(\"TWITTER_PASSWORD\") ||\n                process.env.TWITTER_PASSWORD,\n            TWITTER_EMAIL:\n                runtime.getSetting(\"TWITTER_EMAIL\") ||\n                process.env.TWITTER_EMAIL,\n            TWITTER_COOKIES:\n                runtime.getSetting(\"TWITTER_COOKIES\") ||\n                process.env.TWITTER_COOKIES,\n            MAX_TWEET_LENGTH:\n                runtime.getSetting(\"MAX_TWEET_LENGTH\") ||\n                process.env.MAX_TWEET_LENGTH ||\n                DEFAULT_MAX_TWEET_LENGTH.toString(),\n        };\n\n        return twitterEnvSchema.parse(twitterConfig);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Twitter configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import { SearchMode, Tweet } from \"agent-twitter-client\";\nimport {\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    messageCompletionFooter,\n    shouldRespondFooter,\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n    stringToUuid,\n    elizaLogger,\n    getEmbeddingZeroVector,\n} from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base\";\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\n\nexport const twitterMessageHandlerTemplate =\n    `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\n{{recentPosts}}\n\n# Task: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\nCurrent Post:\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n{{actions}}\n# Task: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\n{{actionNames}}\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)\n{{currentPost}}\n` + messageCompletionFooter;\n\nexport const twitterShouldRespondTemplate = (targetUsersStr: string) =>\n    `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"true\" or \"false\".\n\nResponse options are RESPOND, IGNORE and STOP.\n\nPRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.\n\nFor other users:\n- {{agentName}} should RESPOND to messages directed at them\n- {{agentName}} should RESPOND to conversations relevant to their background\n- {{agentName}} should IGNORE irrelevant messages\n- {{agentName}} should IGNORE very short messages unless directly addressed\n- {{agentName}} should STOP if asked to stop\n- {{agentName}} should STOP if conversation is concluded\n- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.\n\n{{recentPosts}}\n\nIMPORTANT: For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.\n\n{{recentPosts}}\n\nIMPORTANT: {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\n\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n\n{{formattedConversation}}\n\n# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.\n` + shouldRespondFooter;\n\nexport class TwitterInteractionClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n    }\n\n    async start() {\n        const handleTwitterInteractionsLoop = () => {\n            this.handleTwitterInteractions();\n            setTimeout(\n                handleTwitterInteractionsLoop,\n                Number(\n                    this.runtime.getSetting(\"TWITTER_POLL_INTERVAL\") || 120\n                ) * 1000 // Default to 2 minutes\n            );\n        };\n        handleTwitterInteractionsLoop();\n    }\n\n    async handleTwitterInteractions() {\n        elizaLogger.log(\"Checking Twitter interactions\");\n        // Read from environment variable, fallback to default list if not set\n        const targetUsersStr = this.runtime.getSetting(\"TWITTER_TARGET_USERS\");\n\n        const twitterUsername = this.client.profile.username;\n        try {\n            // Check for mentions\n            const mentionCandidates = (\n                await this.client.fetchSearchTweets(\n                    `@${twitterUsername}`,\n                    20,\n                    SearchMode.Latest\n                )\n            ).tweets;\n\n            elizaLogger.log(\n                \"Completed checking mentioned tweets:\",\n                mentionCandidates.length\n            );\n            let uniqueTweetCandidates = [...mentionCandidates];\n            // Only process target users if configured\n            if (targetUsersStr && targetUsersStr.trim()) {\n                const TARGET_USERS = targetUsersStr\n                    .split(\",\")\n                    .map((u) => u.trim())\n                    .filter((u) => u.length > 0); // Filter out empty strings after split\n\n                elizaLogger.log(\"Processing target users:\", TARGET_USERS);\n\n                if (TARGET_USERS.length > 0) {\n                    // Create a map to store tweets by user\n                    const tweetsByUser = new Map<string, Tweet[]>();\n\n                    // Fetch tweets from all target users\n                    for (const username of TARGET_USERS) {\n                        try {\n                            const userTweets = (\n                                await this.client.twitterClient.fetchSearchTweets(\n                                    `from:${username}`,\n                                    3,\n                                    SearchMode.Latest\n                                )\n                            ).tweets;\n\n                            // Filter for unprocessed, non-reply, recent tweets\n                            const validTweets = userTweets.filter((tweet) => {\n                                const isUnprocessed =\n                                    !this.client.lastCheckedTweetId ||\n                                    parseInt(tweet.id) >\n                                        this.client.lastCheckedTweetId;\n                                const isRecent =\n                                    Date.now() - tweet.timestamp * 1000 <\n                                    2 * 60 * 60 * 1000;\n\n                                elizaLogger.log(`Tweet ${tweet.id} checks:`, {\n                                    isUnprocessed,\n                                    isRecent,\n                                    isReply: tweet.isReply,\n                                    isRetweet: tweet.isRetweet,\n                                });\n\n                                return (\n                                    isUnprocessed &&\n                                    !tweet.isReply &&\n                                    !tweet.isRetweet &&\n                                    isRecent\n                                );\n                            });\n\n                            if (validTweets.length > 0) {\n                                tweetsByUser.set(username, validTweets);\n                                elizaLogger.log(\n                                    `Found ${validTweets.length} valid tweets from ${username}`\n                                );\n                            }\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error fetching tweets for ${username}:`,\n                                error\n                            );\n                            continue;\n                        }\n                    }\n\n                    // Select one tweet from each user that has tweets\n                    const selectedTweets: Tweet[] = [];\n                    for (const [username, tweets] of tweetsByUser) {\n                        if (tweets.length > 0) {\n                            // Randomly select one tweet from this user\n                            const randomTweet =\n                                tweets[\n                                    Math.floor(Math.random() * tweets.length)\n                                ];\n                            selectedTweets.push(randomTweet);\n                            elizaLogger.log(\n                                `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`\n                            );\n                        }\n                    }\n\n                    // Add selected tweets to candidates\n                    uniqueTweetCandidates = [\n                        ...mentionCandidates,\n                        ...selectedTweets,\n                    ];\n                }\n            } else {\n                elizaLogger.log(\n                    \"No target users configured, processing only mentions\"\n                );\n            }\n\n            // Sort tweet candidates by ID in ascending order\n            uniqueTweetCandidates\n                .sort((a, b) => a.id.localeCompare(b.id))\n                .filter((tweet) => tweet.userId !== this.client.profile.id);\n\n            // for each tweet candidate, handle the tweet\n            for (const tweet of uniqueTweetCandidates) {\n                if (\n                    !this.client.lastCheckedTweetId ||\n                    BigInt(tweet.id) > this.client.lastCheckedTweetId\n                ) {\n                    // Generate the tweetId UUID the same way it's done in handleTweet\n                    const tweetId = stringToUuid(\n                        tweet.id + \"-\" + this.runtime.agentId\n                    );\n\n                    // Check if we've already processed this tweet\n                    const existingResponse =\n                        await this.runtime.messageManager.getMemoryById(\n                            tweetId\n                        );\n\n                    if (existingResponse) {\n                        elizaLogger.log(\n                            `Already responded to tweet ${tweet.id}, skipping`\n                        );\n                        continue;\n                    }\n                    elizaLogger.log(\"New Tweet found\", tweet.permanentUrl);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userIdUUID =\n                        tweet.userId === this.client.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId!);\n\n                    await this.runtime.ensureConnection(\n                        userIdUUID,\n                        roomId,\n                        tweet.username,\n                        tweet.name,\n                        \"twitter\"\n                    );\n\n                    const thread = await buildConversationThread(\n                        tweet,\n                        this.client\n                    );\n\n                    const message = {\n                        content: { text: tweet.text },\n                        agentId: this.runtime.agentId,\n                        userId: userIdUUID,\n                        roomId,\n                    };\n\n                    await this.handleTweet({\n                        tweet,\n                        message,\n                        thread,\n                    });\n\n                    // Update the last checked tweet ID after processing each tweet\n                    this.client.lastCheckedTweetId = BigInt(tweet.id);\n                }\n            }\n\n            // Save the latest checked tweet ID to the file\n            await this.client.cacheLatestCheckedTweetId();\n\n            elizaLogger.log(\"Finished checking Twitter interactions\");\n        } catch (error) {\n            elizaLogger.error(\"Error handling Twitter interactions:\", error);\n        }\n    }\n\n    private async handleTweet({\n        tweet,\n        message,\n        thread,\n    }: {\n        tweet: Tweet;\n        message: Memory;\n        thread: Tweet[];\n    }) {\n        if (tweet.userId === this.client.profile.id) {\n            // console.log(\"skipping tweet from bot itself\", tweet.id);\n            // Skip processing if the tweet is from the bot itself\n            return;\n        }\n\n        if (!message.content.text) {\n            elizaLogger.log(\"Skipping Tweet with no text\", tweet.id);\n            return { text: \"\", action: \"IGNORE\" };\n        }\n\n        elizaLogger.log(\"Processing Tweet: \", tweet.id);\n        const formatTweet = (tweet: Tweet) => {\n            return `  ID: ${tweet.id}\n  From: ${tweet.name} (@${tweet.username})\n  Text: ${tweet.text}`;\n        };\n        const currentPost = formatTweet(tweet);\n\n        elizaLogger.debug(\"Thread: \", thread);\n        const formattedConversation = thread\n            .map(\n                (tweet) => `@${tweet.username} (${new Date(\n                    tweet.timestamp * 1000\n                ).toLocaleString(\"en-US\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                    month: \"short\",\n                    day: \"numeric\",\n                })}):\n        ${tweet.text}`\n            )\n            .join(\"\\n\\n\");\n\n        elizaLogger.debug(\"formattedConversation: \", formattedConversation);\n\n        let state = await this.runtime.composeState(message, {\n            twitterClient: this.client.twitterClient,\n            twitterUserName: this.runtime.getSetting(\"TWITTER_USERNAME\"),\n            currentPost,\n            formattedConversation,\n        });\n\n        // check if the tweet exists, save if it doesn't\n        const tweetId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n        const tweetExists =\n            await this.runtime.messageManager.getMemoryById(tweetId);\n\n        if (!tweetExists) {\n            elizaLogger.log(\"tweet does not exist, saving\");\n            const userIdUUID = stringToUuid(tweet.userId as string);\n            const roomId = stringToUuid(tweet.conversationId);\n\n            const message = {\n                id: tweetId,\n                agentId: this.runtime.agentId,\n                content: {\n                    text: tweet.text,\n                    url: tweet.permanentUrl,\n                    inReplyTo: tweet.inReplyToStatusId\n                        ? stringToUuid(\n                              tweet.inReplyToStatusId +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n                },\n                userId: userIdUUID,\n                roomId,\n                createdAt: tweet.timestamp * 1000,\n            };\n            this.client.saveRequestMessage(message, state);\n        }\n\n        // 1. Get the raw target users string from settings\n        const targetUsersStr = this.runtime.getSetting(\"TWITTER_TARGET_USERS\");\n\n        // 2. Process the string to get valid usernames\n        const validTargetUsersStr =\n            targetUsersStr && targetUsersStr.trim()\n                ? targetUsersStr\n                      .split(\",\") // Split by commas: \"user1,user2\" -> [\"user1\", \"user2\"]\n                      .map((u) => u.trim()) // Remove whitespace: [\" user1 \", \"user2 \"] -> [\"user1\", \"user2\"]\n                      .filter((u) => u.length > 0)\n                      .join(\",\")\n                : \"\";\n\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates?.twitterShouldRespondTemplate ||\n                this.runtime.character?.templates?.shouldRespondTemplate ||\n                twitterShouldRespondTemplate(validTargetUsersStr),\n        });\n\n        const shouldRespond = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.MEDIUM,\n        });\n\n        // Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\n        if (shouldRespond !== \"RESPOND\") {\n            elizaLogger.log(\"Not responding to message\");\n            return { text: \"Response Decision:\", action: shouldRespond };\n        }\n\n        const context = composeContext({\n            state,\n            template:\n                this.runtime.character.templates\n                    ?.twitterMessageHandlerTemplate ||\n                this.runtime.character?.templates?.messageHandlerTemplate ||\n                twitterMessageHandlerTemplate,\n        });\n\n        elizaLogger.debug(\"Interactions prompt:\\n\" + context);\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n\n        const removeQuotes = (str: string) =>\n            str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n        const stringId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n\n        response.inReplyTo = stringId;\n\n        response.text = removeQuotes(response.text);\n\n        if (response.text) {\n            try {\n                const callback: HandlerCallback = async (response: Content) => {\n                    const memories = await sendTweet(\n                        this.client,\n                        response,\n                        message.roomId,\n                        this.runtime.getSetting(\"TWITTER_USERNAME\"),\n                        tweet.id\n                    );\n                    return memories;\n                };\n\n                const responseMessages = await callback(response);\n\n                state = (await this.runtime.updateRecentMessageState(\n                    state\n                )) as State;\n\n                for (const responseMessage of responseMessages) {\n                    if (\n                        responseMessage ===\n                        responseMessages[responseMessages.length - 1]\n                    ) {\n                        responseMessage.content.action = response.action;\n                    } else {\n                        responseMessage.content.action = \"CONTINUE\";\n                    }\n                    await this.runtime.messageManager.createMemory(\n                        responseMessage\n                    );\n                }\n\n                await this.runtime.processActions(\n                    message,\n                    responseMessages,\n                    state,\n                    callback\n                );\n\n                const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`;\n\n                await this.runtime.cacheManager.set(\n                    `twitter/tweet_generation_${tweet.id}.txt`,\n                    responseInfo\n                );\n                await wait();\n            } catch (error) {\n                elizaLogger.error(`Error sending response tweet: ${error}`);\n            }\n        }\n    }\n\n    async buildConversationThread(\n        tweet: Tweet,\n        maxReplies: number = 10\n    ): Promise<Tweet[]> {\n        const thread: Tweet[] = [];\n        const visited: Set<string> = new Set();\n\n        async function processThread(currentTweet: Tweet, depth: number = 0) {\n            elizaLogger.log(\"Processing tweet:\", {\n                id: currentTweet.id,\n                inReplyToStatusId: currentTweet.inReplyToStatusId,\n                depth: depth,\n            });\n\n            if (!currentTweet) {\n                elizaLogger.log(\"No current tweet found for thread building\");\n                return;\n            }\n\n            if (depth >= maxReplies) {\n                elizaLogger.log(\"Reached maximum reply depth\", depth);\n                return;\n            }\n\n            // Handle memory storage\n            const memory = await this.runtime.messageManager.getMemoryById(\n                stringToUuid(currentTweet.id + \"-\" + this.runtime.agentId)\n            );\n            if (!memory) {\n                const roomId = stringToUuid(\n                    currentTweet.conversationId + \"-\" + this.runtime.agentId\n                );\n                const userId = stringToUuid(currentTweet.userId);\n\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    currentTweet.username,\n                    currentTweet.name,\n                    \"twitter\"\n                );\n\n                this.runtime.messageManager.createMemory({\n                    id: stringToUuid(\n                        currentTweet.id + \"-\" + this.runtime.agentId\n                    ),\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: currentTweet.text,\n                        source: \"twitter\",\n                        url: currentTweet.permanentUrl,\n                        inReplyTo: currentTweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  currentTweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    },\n                    createdAt: currentTweet.timestamp * 1000,\n                    roomId,\n                    userId:\n                        currentTweet.userId === this.twitterUserId\n                            ? this.runtime.agentId\n                            : stringToUuid(currentTweet.userId),\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            if (visited.has(currentTweet.id)) {\n                elizaLogger.log(\"Already visited tweet:\", currentTweet.id);\n                return;\n            }\n\n            visited.add(currentTweet.id);\n            thread.unshift(currentTweet);\n\n            elizaLogger.debug(\"Current thread state:\", {\n                length: thread.length,\n                currentDepth: depth,\n                tweetId: currentTweet.id,\n            });\n\n            if (currentTweet.inReplyToStatusId) {\n                elizaLogger.log(\n                    \"Fetching parent tweet:\",\n                    currentTweet.inReplyToStatusId\n                );\n                try {\n                    const parentTweet = await this.twitterClient.getTweet(\n                        currentTweet.inReplyToStatusId\n                    );\n\n                    if (parentTweet) {\n                        elizaLogger.log(\"Found parent tweet:\", {\n                            id: parentTweet.id,\n                            text: parentTweet.text?.slice(0, 50),\n                        });\n                        await processThread(parentTweet, depth + 1);\n                    } else {\n                        elizaLogger.log(\n                            \"No parent tweet found for:\",\n                            currentTweet.inReplyToStatusId\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.log(\"Error fetching parent tweet:\", {\n                        tweetId: currentTweet.inReplyToStatusId,\n                        error,\n                    });\n                }\n            } else {\n                elizaLogger.log(\n                    \"Reached end of reply chain at:\",\n                    currentTweet.id\n                );\n            }\n        }\n\n        // Need to bind this context for the inner function\n        await processThread.bind(this)(tweet, 0);\n\n        elizaLogger.debug(\"Final thread built:\", {\n            totalTweets: thread.length,\n            tweetIds: thread.map((t) => ({\n                id: t.id,\n                text: t.text?.slice(0, 50),\n            })),\n        });\n\n        return thread;\n    }\n}\n","import { Tweet } from \"agent-twitter-client\";\nimport { getEmbeddingZeroVector } from \"@ai16z/eliza\";\nimport { Content, Memory, UUID } from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base\";\nimport { elizaLogger } from \"@ai16z/eliza\";\nimport { DEFAULT_MAX_TWEET_LENGTH } from \"./environment\";\nimport { Media } from \"@ai16z/eliza\";\nimport fs from \"fs\";\nimport path from \"path\";\n\nexport const wait = (minTime: number = 1000, maxTime: number = 3000) => {\n    const waitTime =\n        Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\n};\n\nexport const isValidTweet = (tweet: Tweet): boolean => {\n    // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\n    const hashtagCount = (tweet.text?.match(/#/g) || []).length;\n    const atCount = (tweet.text?.match(/@/g) || []).length;\n    const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\n    const totalCount = hashtagCount + atCount + dollarSignCount;\n\n    return (\n        hashtagCount <= 1 &&\n        atCount <= 2 &&\n        dollarSignCount <= 1 &&\n        totalCount <= 3\n    );\n};\n\nexport async function buildConversationThread(\n    tweet: Tweet,\n    client: ClientBase,\n    maxReplies: number = 10\n): Promise<Tweet[]> {\n    const thread: Tweet[] = [];\n    const visited: Set<string> = new Set();\n\n    async function processThread(currentTweet: Tweet, depth: number = 0) {\n        elizaLogger.debug(\"Processing tweet:\", {\n            id: currentTweet.id,\n            inReplyToStatusId: currentTweet.inReplyToStatusId,\n            depth: depth,\n        });\n\n        if (!currentTweet) {\n            elizaLogger.debug(\"No current tweet found for thread building\");\n            return;\n        }\n\n        // Stop if we've reached our reply limit\n        if (depth >= maxReplies) {\n            elizaLogger.debug(\"Reached maximum reply depth\", depth);\n            return;\n        }\n\n        // Handle memory storage\n        const memory = await client.runtime.messageManager.getMemoryById(\n            stringToUuid(currentTweet.id + \"-\" + client.runtime.agentId)\n        );\n        if (!memory) {\n            const roomId = stringToUuid(\n                currentTweet.conversationId + \"-\" + client.runtime.agentId\n            );\n            const userId = stringToUuid(currentTweet.userId);\n\n            await client.runtime.ensureConnection(\n                userId,\n                roomId,\n                currentTweet.username,\n                currentTweet.name,\n                \"twitter\"\n            );\n\n            await client.runtime.messageManager.createMemory({\n                id: stringToUuid(\n                    currentTweet.id + \"-\" + client.runtime.agentId\n                ),\n                agentId: client.runtime.agentId,\n                content: {\n                    text: currentTweet.text,\n                    source: \"twitter\",\n                    url: currentTweet.permanentUrl,\n                    inReplyTo: currentTweet.inReplyToStatusId\n                        ? stringToUuid(\n                              currentTweet.inReplyToStatusId +\n                                  \"-\" +\n                                  client.runtime.agentId\n                          )\n                        : undefined,\n                },\n                createdAt: currentTweet.timestamp * 1000,\n                roomId,\n                userId:\n                    currentTweet.userId === client.profile.id\n                        ? client.runtime.agentId\n                        : stringToUuid(currentTweet.userId),\n                embedding: getEmbeddingZeroVector(),\n            });\n        }\n\n        if (visited.has(currentTweet.id)) {\n            elizaLogger.debug(\"Already visited tweet:\", currentTweet.id);\n            return;\n        }\n\n        visited.add(currentTweet.id);\n        thread.unshift(currentTweet);\n\n        elizaLogger.debug(\"Current thread state:\", {\n            length: thread.length,\n            currentDepth: depth,\n            tweetId: currentTweet.id,\n        });\n\n        // If there's a parent tweet, fetch and process it\n        if (currentTweet.inReplyToStatusId) {\n            elizaLogger.debug(\n                \"Fetching parent tweet:\",\n                currentTweet.inReplyToStatusId\n            );\n            try {\n                const parentTweet = await client.twitterClient.getTweet(\n                    currentTweet.inReplyToStatusId\n                );\n\n                if (parentTweet) {\n                    elizaLogger.debug(\"Found parent tweet:\", {\n                        id: parentTweet.id,\n                        text: parentTweet.text?.slice(0, 50),\n                    });\n                    await processThread(parentTweet, depth + 1);\n                } else {\n                    elizaLogger.debug(\n                        \"No parent tweet found for:\",\n                        currentTweet.inReplyToStatusId\n                    );\n                }\n            } catch (error) {\n                elizaLogger.error(\"Error fetching parent tweet:\", {\n                    tweetId: currentTweet.inReplyToStatusId,\n                    error,\n                });\n            }\n        } else {\n            elizaLogger.debug(\n                \"Reached end of reply chain at:\",\n                currentTweet.id\n            );\n        }\n    }\n\n    await processThread(tweet, 0);\n\n    elizaLogger.debug(\"Final thread built:\", {\n        totalTweets: thread.length,\n        tweetIds: thread.map((t) => ({\n            id: t.id,\n            text: t.text?.slice(0, 50),\n        })),\n    });\n\n    return thread;\n}\n\nexport async function sendTweet(\n    client: ClientBase,\n    content: Content,\n    roomId: UUID,\n    twitterUsername: string,\n    inReplyTo: string\n): Promise<Memory[]> {\n    const tweetChunks = splitTweetContent(\n        content.text,\n        Number(client.runtime.getSetting(\"MAX_TWEET_LENGTH\")) ||\n            DEFAULT_MAX_TWEET_LENGTH\n    );\n    const sentTweets: Tweet[] = [];\n    let previousTweetId = inReplyTo;\n\n    for (const chunk of tweetChunks) {\n        let mediaData: { data: Buffer; mediaType: string }[] | undefined;\n\n        if (content.attachments && content.attachments.length > 0) {\n            mediaData = await Promise.all(\n                content.attachments.map(async (attachment: Media) => {\n                    if (/^(http|https):\\/\\//.test(attachment.url)) {\n                        // Handle HTTP URLs\n                        const response = await fetch(attachment.url);\n                        if (!response.ok) {\n                            throw new Error(\n                                `Failed to fetch file: ${attachment.url}`\n                            );\n                        }\n                        const mediaBuffer = Buffer.from(\n                            await response.arrayBuffer()\n                        );\n                        const mediaType = attachment.contentType;\n                        return { data: mediaBuffer, mediaType };\n                    } else if (fs.existsSync(attachment.url)) {\n                        // Handle local file paths\n                        const mediaBuffer = await fs.promises.readFile(\n                            path.resolve(attachment.url)\n                        );\n                        const mediaType = attachment.contentType;\n                        return { data: mediaBuffer, mediaType };\n                    } else {\n                        throw new Error(\n                            `File not found: ${attachment.url}. Make sure the path is correct.`\n                        );\n                    }\n                })\n            );\n        }\n        const result = await client.requestQueue.add(\n            async () =>\n                await client.twitterClient.sendTweet(\n                    chunk.trim(),\n                    previousTweetId,\n                    mediaData\n                )\n        );\n        const body = await result.json();\n\n        // if we have a response\n        if (body?.data?.create_tweet?.tweet_results?.result) {\n            // Parse the response\n            const tweetResult = body.data.create_tweet.tweet_results.result;\n            const finalTweet: Tweet = {\n                id: tweetResult.rest_id,\n                text: tweetResult.legacy.full_text,\n                conversationId: tweetResult.legacy.conversation_id_str,\n                timestamp:\n                    new Date(tweetResult.legacy.created_at).getTime() / 1000,\n                userId: tweetResult.legacy.user_id_str,\n                inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n                permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n                hashtags: [],\n                mentions: [],\n                photos: [],\n                thread: [],\n                urls: [],\n                videos: [],\n            };\n            sentTweets.push(finalTweet);\n            previousTweetId = finalTweet.id;\n        } else {\n            console.error(\"Error sending chunk\", chunk, \"repsonse:\", body);\n        }\n\n        // Wait a bit between tweets to avoid rate limiting issues\n        await wait(1000, 2000);\n    }\n\n    const memories: Memory[] = sentTweets.map((tweet) => ({\n        id: stringToUuid(tweet.id + \"-\" + client.runtime.agentId),\n        agentId: client.runtime.agentId,\n        userId: client.runtime.agentId,\n        content: {\n            text: tweet.text,\n            source: \"twitter\",\n            url: tweet.permanentUrl,\n            inReplyTo: tweet.inReplyToStatusId\n                ? stringToUuid(\n                      tweet.inReplyToStatusId + \"-\" + client.runtime.agentId\n                  )\n                : undefined,\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: tweet.timestamp * 1000,\n    }));\n\n    return memories;\n}\n\nfunction splitTweetContent(content: string, maxLength: number): string[] {\n    const paragraphs = content.split(\"\\n\\n\").map((p) => p.trim());\n    const tweets: string[] = [];\n    let currentTweet = \"\";\n\n    for (const paragraph of paragraphs) {\n        if (!paragraph) continue;\n\n        if ((currentTweet + \"\\n\\n\" + paragraph).trim().length <= maxLength) {\n            if (currentTweet) {\n                currentTweet += \"\\n\\n\" + paragraph;\n            } else {\n                currentTweet = paragraph;\n            }\n        } else {\n            if (currentTweet) {\n                tweets.push(currentTweet.trim());\n            }\n            if (paragraph.length <= maxLength) {\n                currentTweet = paragraph;\n            } else {\n                // Split long paragraph into smaller chunks\n                const chunks = splitParagraph(paragraph, maxLength);\n                tweets.push(...chunks.slice(0, -1));\n                currentTweet = chunks[chunks.length - 1];\n            }\n        }\n    }\n\n    if (currentTweet) {\n        tweets.push(currentTweet.trim());\n    }\n\n    return tweets;\n}\n\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\n    // eslint-disable-next-line\n    const sentences = paragraph.match(/[^\\.!\\?]+[\\.!\\?]+|[^\\.!\\?]+$/g) || [\n        paragraph,\n    ];\n    const chunks: string[] = [];\n    let currentChunk = \"\";\n\n    for (const sentence of sentences) {\n        if ((currentChunk + \" \" + sentence).trim().length <= maxLength) {\n            if (currentChunk) {\n                currentChunk += \" \" + sentence;\n            } else {\n                currentChunk = sentence;\n            }\n        } else {\n            if (currentChunk) {\n                chunks.push(currentChunk.trim());\n            }\n            if (sentence.length <= maxLength) {\n                currentChunk = sentence;\n            } else {\n                // Split long sentence into smaller pieces\n                const words = sentence.split(\" \");\n                currentChunk = \"\";\n                for (const word of words) {\n                    if (\n                        (currentChunk + \" \" + word).trim().length <= maxLength\n                    ) {\n                        if (currentChunk) {\n                            currentChunk += \" \" + word;\n                        } else {\n                            currentChunk = word;\n                        }\n                    } else {\n                        if (currentChunk) {\n                            chunks.push(currentChunk.trim());\n                        }\n                        currentChunk = word;\n                    }\n                }\n            }\n        }\n    }\n\n    if (currentChunk) {\n        chunks.push(currentChunk.trim());\n    }\n\n    return chunks;\n}\n","import { Tweet } from \"agent-twitter-client\";\nimport {\n    composeContext,\n    generateText,\n    getEmbeddingZeroVector,\n    IAgentRuntime,\n    ModelClass,\n    stringToUuid,\n    parseBooleanFromText,\n} from \"@ai16z/eliza\";\nimport { elizaLogger } from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base.ts\";\nimport { postActionResponseFooter } from \"@ai16z/eliza\";\nimport { generateTweetActions } from \"@ai16z/eliza\";\nimport { IImageDescriptionService, ServiceType } from \"@ai16z/eliza\";\nimport { buildConversationThread } from \"./utils.ts\";\nimport { twitterMessageHandlerTemplate } from \"./interactions.ts\";\n\nconst twitterPostTemplate = `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\n# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should be 1, 2, or 3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\\\n\\\\n (double spaces) between statements if there are multiple statements in your response.`;\n\nexport const twitterActionTemplate =\n    `\n# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:\n{{bio}}\n{{postDirections}}\n\nGuidelines:\n- Highly selective engagement\n- Direct mentions are priority\n- Skip: low-effort content, off-topic, repetitive\n\nActions (respond only with tags):\n[LIKE] - Resonates with interests (9.5/10)\n[RETWEET] - Perfect character alignment (9/10)\n[QUOTE] - Can add unique value (8/10)\n[REPLY] - Memetic opportunity (9/10)\n\nTweet:\n{{currentTweet}}\n\n# Respond with qualifying action tags only.` + postActionResponseFooter;\n\nconst MAX_TWEET_LENGTH = 240;\n\n/**\n * Truncate text to fit within the Twitter character limit, ensuring it ends at a complete sentence.\n */\nfunction truncateToCompleteSentence(\n    text: string,\n    maxTweetLength: number\n): string {\n    if (text.length <= maxTweetLength) {\n        return text;\n    }\n\n    // Attempt to truncate at the last period within the limit\n    const truncatedAtPeriod = text.slice(\n        0,\n        text.lastIndexOf(\".\", maxTweetLength) + 1\n    );\n    if (truncatedAtPeriod.trim().length > 0) {\n        return truncatedAtPeriod.trim();\n    }\n\n    // If no period is found, truncate to the nearest whitespace\n    const truncatedAtSpace = text.slice(\n        0,\n        text.lastIndexOf(\" \", maxTweetLength)\n    );\n    if (truncatedAtSpace.trim().length > 0) {\n        return truncatedAtSpace.trim() + \"...\";\n    }\n\n    // Fallback: Hard truncate and add ellipsis\n    return text.slice(0, maxTweetLength - 3).trim() + \"...\";\n}\n\nexport class TwitterPostClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    twitterUsername: string;\n    private isProcessing: boolean = false;\n    private lastProcessTime: number = 0;\n    private stopProcessingActions: boolean = false;\n\n    async start(postImmediately: boolean = false) {\n        if (!this.client.profile) {\n            await this.client.init();\n        }\n\n        const generateNewTweetLoop = async () => {\n            const lastPost = await this.runtime.cacheManager.get<{\n                timestamp: number;\n            }>(\"twitter/\" + this.twitterUsername + \"/lastPost\");\n\n            const lastPostTimestamp = lastPost?.timestamp ?? 0;\n            const minMinutes =\n                parseInt(this.runtime.getSetting(\"POST_INTERVAL_MIN\")) || 90;\n            const maxMinutes =\n                parseInt(this.runtime.getSetting(\"POST_INTERVAL_MAX\")) || 180;\n            const randomMinutes =\n                Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) +\n                minMinutes;\n            const delay = randomMinutes * 60 * 1000;\n\n            if (Date.now() > lastPostTimestamp + delay) {\n                await this.generateNewTweet();\n            }\n\n            setTimeout(() => {\n                generateNewTweetLoop(); // Set up next iteration\n            }, delay);\n\n            elizaLogger.log(`Next tweet scheduled in ${randomMinutes} minutes`);\n        };\n\n        const processActionsLoop = async () => {\n            const actionInterval =\n                parseInt(this.runtime.getSetting(\"ACTION_INTERVAL\")) || 300000; // Default to 5 minutes\n\n            while (!this.stopProcessingActions) {\n                try {\n                    const results = await this.processTweetActions();\n                    if (results) {\n                        elizaLogger.log(`Processed ${results.length} tweets`);\n                        elizaLogger.log(\n                            `Next action processing scheduled in ${actionInterval / 1000} seconds`\n                        );\n                        // Wait for the full interval before next processing\n                        await new Promise((resolve) =>\n                            setTimeout(resolve, actionInterval)\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error in action processing loop:\",\n                        error\n                    );\n                    // Add exponential backoff on error\n                    await new Promise((resolve) => setTimeout(resolve, 30000)); // Wait 30s on error\n                }\n            }\n        };\n\n        if (\n            this.runtime.getSetting(\"POST_IMMEDIATELY\") != null &&\n            this.runtime.getSetting(\"POST_IMMEDIATELY\") != \"\"\n        ) {\n            postImmediately = parseBooleanFromText(\n                this.runtime.getSetting(\"POST_IMMEDIATELY\")\n            );\n        }\n\n        if (postImmediately) {\n            await this.generateNewTweet();\n        }\n        generateNewTweetLoop();\n\n        // Add check for ENABLE_ACTION_PROCESSING before starting the loop\n        const enableActionProcessing = this.runtime.getSetting(\"ENABLE_ACTION_PROCESSING\") ?? false;\n\n        if (enableActionProcessing) {\n            processActionsLoop().catch((error) => {\n                elizaLogger.error(\n                    \"Fatal error in process actions loop:\",\n                    error\n                );\n            });\n        } else {\n            elizaLogger.log(\"Action processing loop disabled by configuration\");\n        }\n        generateNewTweetLoop();\n    }\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.twitterUsername = runtime.getSetting(\"TWITTER_USERNAME\");\n    }\n\n    private async generateNewTweet() {\n        elizaLogger.log(\"Generating new tweet\");\n\n        try {\n            const roomId = stringToUuid(\n                \"twitter_generate_room-\" + this.client.profile.username\n            );\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.client.profile.username,\n                this.runtime.character.name,\n                \"twitter\"\n            );\n\n            const topics = this.runtime.character.topics.join(\", \");\n\n            const state = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: roomId,\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: topics || \"\",\n                        action: \"TWEET\",\n                    },\n                },\n                {\n                    twitterUserName: this.client.profile.username,\n                }\n            );\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.twitterPostTemplate ||\n                    twitterPostTemplate,\n            });\n\n            console.log(\"twitter context:\\n\" + context);\n\n            elizaLogger.debug(\"generate post prompt:\\n\" + context);\n\n            const newTweetContent = await generateText({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            // First attempt to clean content\n            let cleanedContent = \"\";\n\n            // Try parsing as JSON first\n            try {\n                const parsedResponse = JSON.parse(newTweetContent);\n                if (parsedResponse.text) {\n                    cleanedContent = parsedResponse.text;\n                } else if (typeof parsedResponse === \"string\") {\n                    cleanedContent = parsedResponse;\n                }\n            } catch (error) {\n                error.linted = true; // make linter happy since catch needs a variable\n                // If not JSON, clean the raw content\n                cleanedContent = newTweetContent\n                    .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, \"\") // Remove JSON-like wrapper\n                    .replace(/^['\"](.*)['\"]$/g, \"$1\") // Remove quotes\n                    .replace(/\\\\\"/g, '\"') // Unescape quotes\n                    .replace(/\\\\n/g, \"\\n\") // Unescape newlines\n                    .trim();\n            }\n\n            if (!cleanedContent) {\n                elizaLogger.error(\n                    \"Failed to extract valid content from response:\",\n                    {\n                        rawResponse: newTweetContent,\n                        attempted: \"JSON parsing\",\n                    }\n                );\n                return;\n            }\n\n            // Use the helper function to truncate to complete sentence\n            const content = truncateToCompleteSentence(\n                cleanedContent,\n                MAX_TWEET_LENGTH\n            );\n\n            const removeQuotes = (str: string) =>\n                str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n            const fixNewLines = (str: string) => str.replaceAll(/\\\\n/g, \"\\n\");\n\n            // Final cleaning\n            cleanedContent = removeQuotes(fixNewLines(content));\n\n            if (this.runtime.getSetting(\"TWITTER_DRY_RUN\") === \"true\") {\n                elizaLogger.info(\n                    `Dry run: would have posted tweet: ${cleanedContent}`\n                );\n                return;\n            }\n\n            try {\n                elizaLogger.log(`Posting new tweet:\\n ${cleanedContent}`);\n\n                const result = await this.client.requestQueue.add(\n                    async () =>\n                        await this.client.twitterClient.sendTweet(\n                            cleanedContent\n                        )\n                );\n                const body = await result.json();\n                if (!body?.data?.create_tweet?.tweet_results?.result) {\n                    console.error(\"Error sending tweet; Bad response:\", body);\n                    return;\n                }\n                const tweetResult = body.data.create_tweet.tweet_results.result;\n\n                const tweet = {\n                    id: tweetResult.rest_id,\n                    name: this.client.profile.screenName,\n                    username: this.client.profile.username,\n                    text: tweetResult.legacy.full_text,\n                    conversationId: tweetResult.legacy.conversation_id_str,\n                    createdAt: tweetResult.legacy.created_at,\n                    timestamp: new Date(\n                        tweetResult.legacy.created_at\n                    ).getTime(),\n                    userId: this.client.profile.id,\n                    inReplyToStatusId:\n                        tweetResult.legacy.in_reply_to_status_id_str,\n                    permanentUrl: `https://twitter.com/${this.twitterUsername}/status/${tweetResult.rest_id}`,\n                    hashtags: [],\n                    mentions: [],\n                    photos: [],\n                    thread: [],\n                    urls: [],\n                    videos: [],\n                } as Tweet;\n\n                await this.runtime.cacheManager.set(\n                    `twitter/${this.client.profile.username}/lastPost`,\n                    {\n                        id: tweet.id,\n                        timestamp: Date.now(),\n                    }\n                );\n\n                await this.client.cacheTweet(tweet);\n\n                elizaLogger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\n\n                await this.runtime.ensureRoomExists(roomId);\n                await this.runtime.ensureParticipantInRoom(\n                    this.runtime.agentId,\n                    roomId\n                );\n\n                await this.runtime.messageManager.createMemory({\n                    id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                    userId: this.runtime.agentId,\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: newTweetContent.trim(),\n                        url: tweet.permanentUrl,\n                        source: \"twitter\",\n                    },\n                    roomId,\n                    embedding: getEmbeddingZeroVector(),\n                    createdAt: tweet.timestamp,\n                });\n            } catch (error) {\n                elizaLogger.error(\"Error sending tweet:\", error);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error generating new tweet:\", error);\n        }\n    }\n\n    private async generateTweetContent(\n        tweetState: any,\n        options?: {\n            template?: string;\n            context?: string;\n        }\n    ): Promise<string> {\n        const context = composeContext({\n            state: tweetState,\n            template:\n                options?.template ||\n                this.runtime.character.templates?.twitterPostTemplate ||\n                twitterPostTemplate,\n        });\n\n        const response = await generateText({\n            runtime: this.runtime,\n            context: options?.context || context,\n            modelClass: ModelClass.SMALL,\n        });\n        console.log(\"generate tweet content response:\\n\" + response);\n\n        // First clean up any markdown and newlines\n        const cleanedResponse = response\n            .replace(/```json\\s*/g, \"\") // Remove ```json\n            .replace(/```\\s*/g, \"\") // Remove any remaining ```\n            .replaceAll(/\\\\n/g, \"\\n\")\n            .trim();\n\n        // Try to parse as JSON first\n        try {\n            const jsonResponse = JSON.parse(cleanedResponse);\n            if (jsonResponse.text) {\n                return this.trimTweetLength(jsonResponse.text);\n            }\n            if (typeof jsonResponse === \"object\") {\n                const possibleContent =\n                    jsonResponse.content ||\n                    jsonResponse.message ||\n                    jsonResponse.response;\n                if (possibleContent) {\n                    return this.trimTweetLength(possibleContent);\n                }\n            }\n        } catch (error) {\n            error.linted = true; // make linter happy since catch needs a variable\n\n            // If JSON parsing fails, treat as plain text\n            elizaLogger.debug(\"Response is not JSON, treating as plain text\");\n        }\n\n        // If not JSON or no valid content found, clean the raw text\n        return this.trimTweetLength(cleanedResponse);\n    }\n\n    // Helper method to ensure tweet length compliance\n    private trimTweetLength(text: string, maxLength: number = 280): string {\n        if (text.length <= maxLength) return text;\n\n        // Try to cut at last sentence\n        const lastSentence = text.slice(0, maxLength).lastIndexOf(\".\");\n        if (lastSentence > 0) {\n            return text.slice(0, lastSentence + 1).trim();\n        }\n\n        // Fallback to word boundary\n        return (\n            text.slice(0, text.lastIndexOf(\" \", maxLength - 3)).trim() + \"...\"\n        );\n    }\n\n    private async processTweetActions() {\n        if (this.isProcessing) {\n            elizaLogger.log(\"Already processing tweet actions, skipping\");\n            return null;\n        }\n\n        try {\n            this.isProcessing = true;\n            this.lastProcessTime = Date.now();\n\n            elizaLogger.log(\"Processing tweet actions\");\n\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.twitterUsername,\n                this.runtime.character.name,\n                \"twitter\"\n            );\n\n            const homeTimeline = await this.client.fetchTimelineForActions(15);\n            const results = [];\n\n            for (const tweet of homeTimeline) {\n                try {\n                    // Skip if we've already processed this tweet\n                    const memory =\n                        await this.runtime.messageManager.getMemoryById(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        );\n                    if (memory) {\n                        elizaLogger.log(\n                            `Already processed tweet ID: ${tweet.id}`\n                        );\n                        continue;\n                    }\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const tweetState = await this.runtime.composeState(\n                        {\n                            userId: this.runtime.agentId,\n                            roomId,\n                            agentId: this.runtime.agentId,\n                            content: { text: \"\", action: \"\" },\n                        },\n                        {\n                            twitterUserName: this.twitterUsername,\n                            currentTweet: `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})\\nText: ${tweet.text}`,\n                        }\n                    );\n\n                    const actionContext = composeContext({\n                        state: tweetState,\n                        template:\n                            this.runtime.character.templates\n                                ?.twitterActionTemplate ||\n                            twitterActionTemplate,\n                    });\n\n                    const actionResponse = await generateTweetActions({\n                        runtime: this.runtime,\n                        context: actionContext,\n                        modelClass: ModelClass.SMALL,\n                    });\n\n                    if (!actionResponse) {\n                        elizaLogger.log(\n                            `No valid actions generated for tweet ${tweet.id}`\n                        );\n                        continue;\n                    }\n\n                    const executedActions: string[] = [];\n\n                    // Execute actions\n                    if (actionResponse.like) {\n                        try {\n                            await this.client.twitterClient.likeTweet(tweet.id);\n                            executedActions.push(\"like\");\n                            elizaLogger.log(`Liked tweet ${tweet.id}`);\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error liking tweet ${tweet.id}:`,\n                                error\n                            );\n                        }\n                    }\n\n                    if (actionResponse.retweet) {\n                        try {\n                            await this.client.twitterClient.retweet(tweet.id);\n                            executedActions.push(\"retweet\");\n                            elizaLogger.log(`Retweeted tweet ${tweet.id}`);\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error retweeting tweet ${tweet.id}:`,\n                                error\n                            );\n                        }\n                    }\n\n                    if (actionResponse.quote) {\n                        try {\n                            // Build conversation thread for context\n                            const thread = await buildConversationThread(\n                                tweet,\n                                this.client\n                            );\n                            const formattedConversation = thread\n                                .map(\n                                    (t) =>\n                                        `@${t.username} (${new Date(t.timestamp * 1000).toLocaleString()}): ${t.text}`\n                                )\n                                .join(\"\\n\\n\");\n\n                            // Generate image descriptions if present\n                            const imageDescriptions = [];\n                            if (tweet.photos?.length > 0) {\n                                elizaLogger.log(\n                                    \"Processing images in tweet for context\"\n                                );\n                                for (const photo of tweet.photos) {\n                                    const description = await this.runtime\n                                        .getService<IImageDescriptionService>(\n                                            ServiceType.IMAGE_DESCRIPTION\n                                        )\n                                        .describeImage(photo.url);\n                                    imageDescriptions.push(description);\n                                }\n                            }\n\n                            // Handle quoted tweet if present\n                            let quotedContent = \"\";\n                            if (tweet.quotedStatusId) {\n                                try {\n                                    const quotedTweet =\n                                        await this.client.twitterClient.getTweet(\n                                            tweet.quotedStatusId\n                                        );\n                                    if (quotedTweet) {\n                                        quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                                    }\n                                } catch (error) {\n                                    elizaLogger.error(\n                                        \"Error fetching quoted tweet:\",\n                                        error\n                                    );\n                                }\n                            }\n\n                            // Compose rich state with all context\n                            const enrichedState =\n                                await this.runtime.composeState(\n                                    {\n                                        userId: this.runtime.agentId,\n                                        roomId: stringToUuid(\n                                            tweet.conversationId +\n                                                \"-\" +\n                                                this.runtime.agentId\n                                        ),\n                                        agentId: this.runtime.agentId,\n                                        content: {\n                                            text: tweet.text,\n                                            action: \"QUOTE\",\n                                        },\n                                    },\n                                    {\n                                        twitterUserName: this.twitterUsername,\n                                        currentPost: `From @${tweet.username}: ${tweet.text}`,\n                                        formattedConversation,\n                                        imageContext:\n                                            imageDescriptions.length > 0\n                                                ? `\\nImages in Tweet:\\n${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join(\"\\n\")}`\n                                                : \"\",\n                                        quotedContent,\n                                    }\n                                );\n\n                            const quoteContent =\n                                await this.generateTweetContent(enrichedState, {\n                                    template:\n                                        this.runtime.character.templates\n                                            ?.twitterMessageHandlerTemplate ||\n                                        twitterMessageHandlerTemplate,\n                                });\n\n                            if (!quoteContent) {\n                                elizaLogger.error(\n                                    \"Failed to generate valid quote tweet content\"\n                                );\n                                return;\n                            }\n\n                            elizaLogger.log(\n                                \"Generated quote tweet content:\",\n                                quoteContent\n                            );\n\n                            // Send the tweet through request queue\n                            const result = await this.client.requestQueue.add(\n                                async () =>\n                                    await this.client.twitterClient.sendQuoteTweet(\n                                        quoteContent,\n                                        tweet.id\n                                    )\n                            );\n\n                            const body = await result.json();\n\n                            if (\n                                body?.data?.create_tweet?.tweet_results?.result\n                            ) {\n                                elizaLogger.log(\n                                    \"Successfully posted quote tweet\"\n                                );\n                                executedActions.push(\"quote\");\n\n                                // Cache generation context for debugging\n                                await this.runtime.cacheManager.set(\n                                    `twitter/quote_generation_${tweet.id}.txt`,\n                                    `Context:\\n${enrichedState}\\n\\nGenerated Quote:\\n${quoteContent}`\n                                );\n                            } else {\n                                elizaLogger.error(\n                                    \"Quote tweet creation failed:\",\n                                    body\n                                );\n                            }\n                        } catch (error) {\n                            elizaLogger.error(\n                                \"Error in quote tweet generation:\",\n                                error\n                            );\n                        }\n                    }\n\n                    if (actionResponse.reply) {\n                        try {\n                            await this.handleTextOnlyReply(\n                                tweet,\n                                tweetState,\n                                executedActions\n                            );\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error replying to tweet ${tweet.id}:`,\n                                error\n                            );\n                        }\n                    }\n\n                    // Add these checks before creating memory\n                    await this.runtime.ensureRoomExists(roomId);\n                    await this.runtime.ensureUserExists(\n                        stringToUuid(tweet.userId),\n                        tweet.username,\n                        tweet.name,\n                        \"twitter\"\n                    );\n                    await this.runtime.ensureParticipantInRoom(\n                        this.runtime.agentId,\n                        roomId\n                    );\n\n                    // Then create the memory\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId: stringToUuid(tweet.userId),\n                        content: {\n                            text: tweet.text,\n                            url: tweet.permanentUrl,\n                            source: \"twitter\",\n                            action: executedActions.join(\",\"),\n                        },\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n\n                    results.push({\n                        tweetId: tweet.id,\n                        parsedActions: actionResponse,\n                        executedActions,\n                    });\n                } catch (error) {\n                    elizaLogger.error(\n                        `Error processing tweet ${tweet.id}:`,\n                        error\n                    );\n                    continue;\n                }\n            }\n\n            return results; // Return results array to indicate completion\n        } catch (error) {\n            elizaLogger.error(\"Error in processTweetActions:\", error);\n            throw error;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    private async handleTextOnlyReply(\n        tweet: Tweet,\n        tweetState: any,\n        executedActions: string[]\n    ) {\n        try {\n            // Build conversation thread for context\n            const thread = await buildConversationThread(tweet, this.client);\n            const formattedConversation = thread\n                .map(\n                    (t) =>\n                        `@${t.username} (${new Date(t.timestamp * 1000).toLocaleString()}): ${t.text}`\n                )\n                .join(\"\\n\\n\");\n\n            // Generate image descriptions if present\n            const imageDescriptions = [];\n            if (tweet.photos?.length > 0) {\n                elizaLogger.log(\"Processing images in tweet for context\");\n                for (const photo of tweet.photos) {\n                    const description = await this.runtime\n                        .getService<IImageDescriptionService>(\n                            ServiceType.IMAGE_DESCRIPTION\n                        )\n                        .describeImage(photo.url);\n                    imageDescriptions.push(description);\n                }\n            }\n\n            // Handle quoted tweet if present\n            let quotedContent = \"\";\n            if (tweet.quotedStatusId) {\n                try {\n                    const quotedTweet =\n                        await this.client.twitterClient.getTweet(\n                            tweet.quotedStatusId\n                        );\n                    if (quotedTweet) {\n                        quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                    }\n                } catch (error) {\n                    elizaLogger.error(\"Error fetching quoted tweet:\", error);\n                }\n            }\n\n            // Compose rich state with all context\n            const enrichedState = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    ),\n                    agentId: this.runtime.agentId,\n                    content: { text: tweet.text, action: \"\" },\n                },\n                {\n                    twitterUserName: this.twitterUsername,\n                    currentPost: `From @${tweet.username}: ${tweet.text}`,\n                    formattedConversation,\n                    imageContext:\n                        imageDescriptions.length > 0\n                            ? `\\nImages in Tweet:\\n${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join(\"\\n\")}`\n                            : \"\",\n                    quotedContent,\n                }\n            );\n\n            // Generate and clean the reply content\n            const replyText = await this.generateTweetContent(enrichedState, {\n                template:\n                    this.runtime.character.templates\n                        ?.twitterMessageHandlerTemplate ||\n                    twitterMessageHandlerTemplate,\n            });\n\n            if (!replyText) {\n                elizaLogger.error(\"Failed to generate valid reply content\");\n                return;\n            }\n\n            elizaLogger.debug(\"Final reply text to be sent:\", replyText);\n\n            // Send the tweet through request queue\n            const result = await this.client.requestQueue.add(\n                async () =>\n                    await this.client.twitterClient.sendTweet(\n                        replyText,\n                        tweet.id\n                    )\n            );\n\n            const body = await result.json();\n\n            if (body?.data?.create_tweet?.tweet_results?.result) {\n                elizaLogger.log(\"Successfully posted reply tweet\");\n                executedActions.push(\"reply\");\n\n                // Cache generation context for debugging\n                await this.runtime.cacheManager.set(\n                    `twitter/reply_generation_${tweet.id}.txt`,\n                    `Context:\\n${enrichedState}\\n\\nGenerated Reply:\\n${replyText}`\n                );\n            } else {\n                elizaLogger.error(\"Tweet reply creation failed:\", body);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error in handleTextOnlyReply:\", error);\n        }\n    }\n\n    async stop() {\n        this.stopProcessingActions = true;\n    }\n}\n","import { SearchMode } from \"agent-twitter-client\";\nimport { composeContext } from \"@ai16z/eliza\";\nimport { generateMessageResponse, generateText } from \"@ai16z/eliza\";\nimport { messageCompletionFooter } from \"@ai16z/eliza\";\nimport {\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    IImageDescriptionService,\n    ModelClass,\n    ServiceType,\n    State,\n} from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base\";\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\n\nconst twitterSearchTemplate =\n    `{{timeline}}\n\n{{providers}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\nAbout {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{postDirections}}\n\n{{recentPosts}}\n\n# Task: Respond to the following post in the style and perspective of {{agentName}} (aka @{{twitterUserName}}). Write a {{adjective}} response for {{agentName}} to say directly in response to the post. don't generalize.\n{{currentPost}}\n\nIMPORTANT: Your response CANNOT be longer than 20 words.\nAim for 1-2 short sentences maximum. Be concise and direct.\n\nYour response should not contain any questions. Brief, concise statements only. No emojis. Use \\\\n\\\\n (double spaces) between statements.\n\n` + messageCompletionFooter;\n\nexport class TwitterSearchClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    twitterUsername: string;\n    private respondedTweets: Set<string> = new Set();\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.twitterUsername = runtime.getSetting(\"TWITTER_USERNAME\");\n    }\n\n    async start() {\n        this.engageWithSearchTermsLoop();\n    }\n\n    private engageWithSearchTermsLoop() {\n        this.engageWithSearchTerms();\n        setTimeout(\n            () => this.engageWithSearchTermsLoop(),\n            (Math.floor(Math.random() * (120 - 60 + 1)) + 60) * 60 * 1000\n        );\n    }\n\n    private async engageWithSearchTerms() {\n        console.log(\"Engaging with search terms\");\n        try {\n            const searchTerm = [...this.runtime.character.topics][\n                Math.floor(Math.random() * this.runtime.character.topics.length)\n            ];\n\n            console.log(\"Fetching search tweets\");\n            // TODO: we wait 5 seconds here to avoid getting rate limited on startup, but we should queue\n            await new Promise((resolve) => setTimeout(resolve, 5000));\n            const recentTweets = await this.client.fetchSearchTweets(\n                searchTerm,\n                20,\n                SearchMode.Top\n            );\n            console.log(\"Search tweets fetched\");\n\n            const homeTimeline = await this.client.fetchHomeTimeline(50);\n\n            await this.client.cacheTimeline(homeTimeline);\n\n            const formattedHomeTimeline =\n                `# ${this.runtime.character.name}'s Home Timeline\\n\\n` +\n                homeTimeline\n                    .map((tweet) => {\n                        return `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : \"\"}\\nText: ${tweet.text}\\n---\\n`;\n                    })\n                    .join(\"\\n\");\n\n            // randomly slice .tweets down to 20\n            const slicedTweets = recentTweets.tweets\n                .sort(() => Math.random() - 0.5)\n                .slice(0, 20);\n\n            if (slicedTweets.length === 0) {\n                console.log(\n                    \"No valid tweets found for the search term\",\n                    searchTerm\n                );\n                return;\n            }\n\n            const prompt = `\n  Here are some tweets related to the search term \"${searchTerm}\":\n\n  ${[...slicedTweets, ...homeTimeline]\n      .filter((tweet) => {\n          // ignore tweets where any of the thread tweets contain a tweet by the bot\n          const thread = tweet.thread;\n          const botTweet = thread.find(\n              (t) => t.username === this.twitterUsername\n          );\n          return !botTweet;\n      })\n      .map(\n          (tweet) => `\n    ID: ${tweet.id}${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : \"\"}\n    From: ${tweet.name} (@${tweet.username})\n    Text: ${tweet.text}\n  `\n      )\n      .join(\"\\n\")}\n\n  Which tweet is the most interesting and relevant for Ruby to reply to? Please provide only the ID of the tweet in your response.\n  Notes:\n    - Respond to English tweets only\n    - Respond to tweets that don't have a lot of hashtags, links, URLs or images\n    - Respond to tweets that are not retweets\n    - Respond to tweets where there is an easy exchange of ideas to have with the user\n    - ONLY respond with the ID of the tweet`;\n\n            const mostInterestingTweetResponse = await generateText({\n                runtime: this.runtime,\n                context: prompt,\n                modelClass: ModelClass.SMALL,\n            });\n\n            const tweetId = mostInterestingTweetResponse.trim();\n            const selectedTweet = slicedTweets.find(\n                (tweet) =>\n                    tweet.id.toString().includes(tweetId) ||\n                    tweetId.includes(tweet.id.toString())\n            );\n\n            if (!selectedTweet) {\n                console.log(\"No matching tweet found for the selected ID\");\n                return console.log(\"Selected tweet ID:\", tweetId);\n            }\n\n            console.log(\"Selected tweet to reply to:\", selectedTweet?.text);\n\n            if (selectedTweet.username === this.twitterUsername) {\n                console.log(\"Skipping tweet from bot itself\");\n                return;\n            }\n\n            const conversationId = selectedTweet.conversationId;\n            const roomId = stringToUuid(\n                conversationId + \"-\" + this.runtime.agentId\n            );\n\n            const userIdUUID = stringToUuid(selectedTweet.userId as string);\n\n            await this.runtime.ensureConnection(\n                userIdUUID,\n                roomId,\n                selectedTweet.username,\n                selectedTweet.name,\n                \"twitter\"\n            );\n\n            // crawl additional conversation tweets, if there are any\n            await buildConversationThread(selectedTweet, this.client);\n\n            const message = {\n                id: stringToUuid(selectedTweet.id + \"-\" + this.runtime.agentId),\n                agentId: this.runtime.agentId,\n                content: {\n                    text: selectedTweet.text,\n                    url: selectedTweet.permanentUrl,\n                    inReplyTo: selectedTweet.inReplyToStatusId\n                        ? stringToUuid(\n                              selectedTweet.inReplyToStatusId +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n                },\n                userId: userIdUUID,\n                roomId,\n                // Timestamps are in seconds, but we need them in milliseconds\n                createdAt: selectedTweet.timestamp * 1000,\n            };\n\n            if (!message.content.text) {\n                return { text: \"\", action: \"IGNORE\" };\n            }\n\n            // Fetch replies and retweets\n            const replies = selectedTweet.thread;\n            const replyContext = replies\n                .filter((reply) => reply.username !== this.twitterUsername)\n                .map((reply) => `@${reply.username}: ${reply.text}`)\n                .join(\"\\n\");\n\n            let tweetBackground = \"\";\n            if (selectedTweet.isRetweet) {\n                const originalTweet = await this.client.requestQueue.add(() =>\n                    this.client.twitterClient.getTweet(selectedTweet.id)\n                );\n                tweetBackground = `Retweeting @${originalTweet.username}: ${originalTweet.text}`;\n            }\n\n            // Generate image descriptions using GPT-4 vision API\n            const imageDescriptions = [];\n            for (const photo of selectedTweet.photos) {\n                const description = await this.runtime\n                    .getService<IImageDescriptionService>(\n                        ServiceType.IMAGE_DESCRIPTION\n                    )\n                    .describeImage(photo.url);\n                imageDescriptions.push(description);\n            }\n\n            let state = await this.runtime.composeState(message, {\n                twitterClient: this.client.twitterClient,\n                twitterUserName: this.twitterUsername,\n                timeline: formattedHomeTimeline,\n                tweetContext: `${tweetBackground}\n\n  Original Post:\n  By @${selectedTweet.username}\n  ${selectedTweet.text}${replyContext.length > 0 && `\\nReplies to original post:\\n${replyContext}`}\n  ${`Original post text: ${selectedTweet.text}`}\n  ${selectedTweet.urls.length > 0 ? `URLs: ${selectedTweet.urls.join(\", \")}\\n` : \"\"}${imageDescriptions.length > 0 ? `\\nImages in Post (Described): ${imageDescriptions.join(\", \")}\\n` : \"\"}\n  `,\n            });\n\n            await this.client.saveRequestMessage(message, state as State);\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.twitterSearchTemplate ||\n                    twitterSearchTemplate,\n            });\n\n            const responseContent = await generateMessageResponse({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.LARGE,\n            });\n\n            responseContent.inReplyTo = message.id;\n\n            const response = responseContent;\n\n            if (!response.text) {\n                console.log(\"Returning: No response text found\");\n                return;\n            }\n\n            console.log(\n                `Bot would respond to tweet ${selectedTweet.id} with: ${response.text}`\n            );\n            try {\n                const callback: HandlerCallback = async (response: Content) => {\n                    const memories = await sendTweet(\n                        this.client,\n                        response,\n                        message.roomId,\n                        this.twitterUsername,\n                        tweetId\n                    );\n                    return memories;\n                };\n\n                const responseMessages = await callback(responseContent);\n\n                state = await this.runtime.updateRecentMessageState(state);\n\n                for (const responseMessage of responseMessages) {\n                    await this.runtime.messageManager.createMemory(\n                        responseMessage,\n                        false\n                    );\n                }\n\n                state = await this.runtime.updateRecentMessageState(state);\n\n                await this.runtime.evaluate(message, state);\n\n                await this.runtime.processActions(\n                    message,\n                    responseMessages,\n                    state,\n                    callback\n                );\n\n                this.respondedTweets.add(selectedTweet.id);\n                const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${selectedTweet.id} - ${selectedTweet.username}: ${selectedTweet.text}\\nAgent's Output:\\n${response.text}`;\n\n                await this.runtime.cacheManager.set(\n                    `twitter/tweet_generation_${selectedTweet.id}.txt`,\n                    responseInfo\n                );\n\n                await wait();\n            } catch (error) {\n                console.error(`Error sending response post: ${error}`);\n            }\n        } catch (error) {\n            console.error(\"Error engaging with search terms:\", error);\n        }\n    }\n}\n"],"mappings":"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","names":["elizaLogger","cookies","existingMemories","existingMemoryIds","tweetsToSave","profile","SearchMode","stringToUuid","elizaLogger","getEmbeddingZeroVector","getEmbeddingZeroVector","stringToUuid","elizaLogger","elizaLogger","stringToUuid","getEmbeddingZeroVector","elizaLogger","SearchMode","stringToUuid","tweet","message","response","getEmbeddingZeroVector","composeContext","getEmbeddingZeroVector","ModelClass","stringToUuid","elizaLogger","elizaLogger","stringToUuid","composeContext","ModelClass","getEmbeddingZeroVector","SearchMode","composeContext","generateMessageResponse","generateText","messageCompletionFooter","ModelClass","ServiceType","stringToUuid","messageCompletionFooter","SearchMode","generateText","ModelClass","stringToUuid","ServiceType","composeContext","generateMessageResponse","response","elizaLogger"]}
\ No newline at end of file
diff -Naur node_modules/@ai16z/client-twitter.original/node_modules/.bin/glob node_modules/@ai16z/client-twitter/node_modules/.bin/glob
--- node_modules/@ai16z/client-twitter.original/node_modules/.bin/glob	1969-12-31 20:00:00.000000000 -0400
+++ node_modules/@ai16z/client-twitter/node_modules/.bin/glob	2025-01-15 22:35:40.961390204 -0400
@@ -0,0 +1,17 @@
+#!/bin/sh
+basedir=$(dirname "$(echo "$0" | sed -e 's,\\,/,g')")
+
+case `uname` in
+    *CYGWIN*) basedir=`cygpath -w "$basedir"`;;
+esac
+
+if [ -z "$NODE_PATH" ]; then
+  export NODE_PATH="/home/oydual3/comic_sans_agent/node_modules/.pnpm/glob@11.0.0/node_modules/glob/dist/esm/node_modules:/home/oydual3/comic_sans_agent/node_modules/.pnpm/glob@11.0.0/node_modules/glob/dist/node_modules:/home/oydual3/comic_sans_agent/node_modules/.pnpm/glob@11.0.0/node_modules/glob/node_modules:/home/oydual3/comic_sans_agent/node_modules/.pnpm/glob@11.0.0/node_modules:/home/oydual3/comic_sans_agent/node_modules/.pnpm/node_modules"
+else
+  export NODE_PATH="/home/oydual3/comic_sans_agent/node_modules/.pnpm/glob@11.0.0/node_modules/glob/dist/esm/node_modules:/home/oydual3/comic_sans_agent/node_modules/.pnpm/glob@11.0.0/node_modules/glob/dist/node_modules:/home/oydual3/comic_sans_agent/node_modules/.pnpm/glob@11.0.0/node_modules/glob/node_modules:/home/oydual3/comic_sans_agent/node_modules/.pnpm/glob@11.0.0/node_modules:/home/oydual3/comic_sans_agent/node_modules/.pnpm/node_modules:$NODE_PATH"
+fi
+if [ -x "$basedir/node" ]; then
+  exec "$basedir/node"  "$basedir/../../../../../../glob@11.0.0/node_modules/glob/dist/esm/bin.mjs" "$@"
+else
+  exec node  "$basedir/../../../../../../glob@11.0.0/node_modules/glob/dist/esm/bin.mjs" "$@"
+fi
diff -Naur node_modules/@ai16z/client-twitter.original/package.json node_modules/@ai16z/client-twitter/package.json
--- node_modules/@ai16z/client-twitter.original/package.json	1969-12-31 20:00:00.000000000 -0400
+++ node_modules/@ai16z/client-twitter/package.json	2025-01-12 20:44:04.768893881 -0400
@@ -0,0 +1,25 @@
+{
+  "name": "@ai16z/client-twitter",
+  "version": "0.1.6",
+  "main": "dist/index.js",
+  "type": "module",
+  "types": "dist/index.d.ts",
+  "dependencies": {
+    "@ai16z/eliza": "0.1.6",
+    "agent-twitter-client": "0.0.16",
+    "glob": "11.0.0",
+    "zod": "3.23.8"
+  },
+  "devDependencies": {
+    "tsup": "8.3.5"
+  },
+  "scripts": {
+    "build": "tsup --format esm --dts",
+    "dev": "tsup --format esm --dts --watch",
+    "lint": "eslint --fix  --cache ."
+  },
+  "peerDependencies": {
+    "whatwg-url": "7.1.0"
+  },
+  "gitHead": "54fe8da8b14e922d5d61a646276d147b417f8b18"
+}
diff -Naur node_modules/@ai16z/client-twitter.original/tsup.config.ts node_modules/@ai16z/client-twitter/tsup.config.ts
--- node_modules/@ai16z/client-twitter.original/tsup.config.ts	1969-12-31 20:00:00.000000000 -0400
+++ node_modules/@ai16z/client-twitter/tsup.config.ts	2025-01-12 20:44:04.624407024 -0400
@@ -0,0 +1,20 @@
+import { defineConfig } from "tsup";
+
+export default defineConfig({
+    entry: ["src/index.ts"],
+    outDir: "dist",
+    sourcemap: true,
+    clean: true,
+    format: ["esm"], // Ensure you're targeting CommonJS
+    external: [
+        "dotenv", // Externalize dotenv to prevent bundling
+        "fs", // Externalize fs to use Node.js built-in module
+        "path", // Externalize other built-ins if necessary
+        "@reflink/reflink",
+        "@node-llama-cpp",
+        "https",
+        "http",
+        "agentkeepalive",
+        // Add other modules you want to externalize
+    ],
+});
